import 'dart:typed_data';

import 'ast.dart';
import 'byte_code_builder.dart';
import 'executor.dart';
import 'functions.dart';
import 'parser.dart';

class ScriptLocalVariable {
  ScriptLocalVariable(this.name, this.index, [this.arraySize]);

  final String name;
  final int index;
  final int? arraySize;
}

class ScriptLocals {
  ScriptLocals([
    Map<String, AstNode>? constants,
    Map<String, ScriptLocalVariable>? variables,
    this.localVariableCount = 0,
  ])  : constants = constants ?? {},
        variables = variables ?? {};

  final Map<String, AstNode> constants;
  final Map<String, ScriptLocalVariable> variables;
  int localVariableCount;

  ScriptLocals clone() =>
      ScriptLocals({...constants}, {...variables}, localVariableCount);
}

class ScriptFunction implements ScriptFunctionDefinition {
  ScriptFunction(this.functionName);

  @override
  final String functionName;

  @override
  bool hasReturnValue = false;

  bool isPure() => statements.isPure();

  ExecutionValue? evaluate(ExecutionContext context) {
    statements.evaluate(context);
    return context.state == ExecutionState.finished
        ? context.returnValue
        : null;
  }

  final parameters = <String>{};
  var locals = ScriptLocals();
  late final StatementListAstNode statements;
  var hasMarked = false;
  var isLocked = false;

  final localsStack = <ScriptLocals>[];

  @override
  int get numberOfParameters => parameters.length;

  @override
  var numberOfLocals = 0;

  void mark(ScriptReachability context) {
    if (hasMarked) return;
    hasMarked = true;
    statements.mark(context);
  }

  void addParameter(String parameterName) {
    parameters.add(parameterName);
    addLocalVar(parameterName, null);
  }

  void addLocalConstant(String constantName, AstNode value) {
    // Copy on write.
    if (localsStack.isNotEmpty && localsStack.last == locals) {
      locals = locals.clone();
    }

    locals.constants[constantName] = value;
  }

  int addLocalVar(String localName, int? arraySize) {
    // Copy on write.
    if (localsStack.isNotEmpty && localsStack.last == locals) {
      locals = locals.clone();
    }

    final index = locals.localVariableCount;
    locals.variables[localName] =
        ScriptLocalVariable(localName, index, arraySize);

    locals.localVariableCount += arraySize ?? 1;
    if (locals.localVariableCount > numberOfLocals) {
      numberOfLocals = locals.localVariableCount;
    }
    return index;
  }

  void beginLocalScope() {
    localsStack.add(locals);
  }

  void endLocalScope() {
    locals = localsStack.removeLast();
  }
}

class ScriptGlobal {
  ScriptGlobal({
    required this.name,
    required this.index,
    required this.arraySize,
    required this.initializer,
  });

  final String name;
  final int index;
  final int? arraySize;
  final AstNode? initializer;
}

class ScriptModule {
  ScriptModule(List<InBuiltScriptFunction> builtInFunctions) {
    for (final builtInFunction in builtInFunctions) {
      functions[builtInFunction.functionName] = builtInFunction;
    }
  }

  factory ScriptModule.header(String header) {
    final result = ScriptModule(const []);
    final parser = Parser(input: header, filename: '', module: result);
    parser.parse();
    return result;
  }

  final functions = <String, ScriptFunctionDefinition>{};
  final constants = <String, AstNode>{};
  final globals = <String, ScriptGlobal>{};

  var globalsUsedCount = 0;

  Uint8List createByteCode({
    required int buttonCount,
    required int encoderCount,
    required int pointerCount,
    required int scriptByteCodeVersion,
  }) =>
      ScriptByteCodeBuilder(
        module: this,
        byteCodeVersion: scriptByteCodeVersion,
        requiredFunctions: ScriptByteCodeBuilder.createScriptFunctionList(
          buttonCount: buttonCount,
          encoderCount: encoderCount,
          pointerCount: pointerCount,
        ),
      ).createByteCode();

  void prepareAutogeneratedCode(ScriptReachability reachability) {
    // Patch or create init function with global variable inits.
    var initFunction = functions['init'] as ScriptFunction?;
    if (initFunction == null) {
      initFunction = ScriptFunction('init');
      initFunction.statements = StatementListAstNode();
      functions['init'] = initFunction;
    } else {
      if (initFunction.hasReturnValue) {
        throw const FormatException('init function should not return a value');
      }
      if (initFunction.numberOfParameters > 0) {
        throw const FormatException(
          'init function should not take any parameters',
        );
      }
    }

    final globalInitializers = <AstNode>[];
    final markedGlobalInitializers = <int>{};

    // Loop until no more initializers are called.
    var continueMarking = true;
    while (continueMarking) {
      continueMarking = false;

      for (final global in globals.values) {
        if (markedGlobalInitializers.contains(global.index)) continue;

        final initializer = global.initializer;
        if (initializer == null) continue;
        if (!reachability.globals.contains(global.index)) continue;
        if (initializer is IntValueAstNode && initializer.value == 0) continue;

        markedGlobalInitializers.add(global.index);
        initializer.mark(reachability);

        continueMarking = true;
      }
    }

    for (final global in globals.values) {
      final initializer = global.initializer;
      if (initializer == null) continue;
      if (!reachability.globals.contains(global.index)) continue;
      if (initializer is IntValueAstNode && initializer.value == 0) continue;

      globalInitializers.add(
        StoreValueAstNode(
          isGlobal: true,
          index: global.index,
          expression: initializer,
          isInitialization: true,
        ),
      );
    }
    initFunction.statements.statements.insertAll(0, globalInitializers);

    // Create tick function if it doesn't exist.
    var tickFunction = functions['tick'] as ScriptFunction?;
    if (tickFunction == null) {
      tickFunction = ScriptFunction('tick');
      tickFunction.statements = StatementListAstNode();
      functions['tick'] = tickFunction;
    } else {
      if (tickFunction.hasReturnValue) {
        throw const FormatException('tick function should not return a value');
      }
      if (tickFunction.numberOfParameters > 0) {
        throw const FormatException(
          'tick function should not take any parameters',
        );
      }
    }
  }
}
