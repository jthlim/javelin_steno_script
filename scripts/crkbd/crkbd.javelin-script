//---------------------------------------------------------------------------
// Default Corne/Jarne script.
//---------------------------------------------------------------------------

// Steno
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |   Tab  |  S1  |   T  |   P  |   H  |  *1  |        |  *2  |   F  |   P  |   L  |   T  |    D   |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Ctrl/Esc|  S2  |   K  |   W  |   R  |  *3  |        |  *4  |   R  |   B  |   G  |   S  |    Z   |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// | Alpha  |      |      |      |      |      |        |      |      |      |      |      |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Cmd  |   A  |   O  |  |   E  |   U  |  #2  |
//                           `--------------------'  `--------------------'
//
// * Tapping Alpha key will switch to Alphabetic mode -- QWERTY, Dvorak, Colemak, Workman
// * Holding it down and pressing other buttons will cause the keyboard to return to steno mode when
//   releasing it. This will also give access to the Symbols, Navigation and Function layers by
//   pressing those keys on the Alphabetic layer.
// * Command and Control activate a temporary qwerty layer

// Alphabetic QWERTY
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |   Tab  |   Q  |   W  |   E  |   R  |   T  |        |   Y  |   U  |   I  |   O  |   P  |  Bksp  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Ctrl/Esc|   A  |   S  |   D  |   F  |   G  |        |   H  |   J  |   K  |   L  | ;  : |  '  "  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Shf/Sten|   Z  |   X  |   C  |   V  |   B  |        |   N  |   M  | ,  < | .  > | /  ? | RShift |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Meta |  Alt |Nav/Sp|  | Space| Sym  |Fn/Ent|
//                           `--------------------'  `--------------------'
//
// Alphabetic Dvorak
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |   Tab  | '  " | ,  < | .  > |   P  |   Y  |        |   F  |   G  |   C  |   R  |   L  |  Bksp  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Ctrl/Esc|   A  |   O  |   E  |   U  |   I  |        |   D  |   H  |   T  |   N  |   S  |  -  _  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Shf/Sten| ;  : |   Q  |   J  |   K  |   X  |        |   B  |   M  |   W  |   V  |   Z  | RShift |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Meta |  Alt |Nav/Sp|  | Space| Sym  |Fn/Ent|
//                           `--------------------'  `--------------------'
//
// Alphabetic Colemak
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |   Tab  |   Q  |   W  |   F  |   P  |   G  |        |   J  |   L  |   U  |   Y  | ;  : |  Bksp  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Ctrl/Esc|   A  |   R  |   S  |   T  |   D  |        |   H  |   N  |   E  |   I  |   O  |  '  "  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Shf/Sten|   Z  |   X  |   C  |   V  |   B  |        |   K  |   M  | ,  < | .  > | /  ? | RShift |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Meta |  Alt |Nav/Sp|  | Space| Sym  |Fn/Ent|
//                           `--------------------'  `--------------------'
//
// Alphabetic Workman
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |   Tab  |   Q  |   D  |   R  |   W  |   B  |        |   J  |   F  |   U  |   P  | ;  : |  Bksp  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Ctrl/Esc|   A  |   S  |   H  |   T  |   G  |        |   Y  |   N  |   E  |   O  |   I  |  '  "  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |Shf/Sten|   Z  |   X  |   M  |   C  |   V  |        |   K  |   L  | ,  < | .  > | /  ? | RShift |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Meta |  Alt |Nav/Sp|  | Space| Sym  |Fn/Ent|
//                           `--------------------'  `--------------------'
//
//
// The layout is selected by pressing LAYOUT on the Settings layer to rotate through the options.
// This can be permanently changed by changing the alphabeticLayout variable's initial value.
//
// For keys marked with two options, holding or pressing with other keys will cause the first option
// to be used, tapping briefly will trigger the second.
//
// Tapping right shift twice will turn on single word capitalization.
// Tapping right shift once then holding it will toggle on and off caps lock.


//
// Symbols
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |    `   |  1   |  2   |  3   |  4   |  5   |        |   6  |  7   |  8   |  9   |  0   |   =    |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |    ~   |  !   |  @   |  #   |  $   |  %   |        |   ^  |  &   |  *   |  (   |  )   |   +    |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |    ?   |  \   |  |   |  -   |  [   |  {   |        |   }  |  ]   |  _   |  .   |  /   |  Magic |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           | Meta |  Alt |Ctl/Sp|  |      |      |      |
//                           `--------------------'  `--------------------'
//
// * Magic has a few different meanings:
//   - By itself, it does nothing.
//   - Following '-' or '=', it means '>'
//   - Following '(' or '\', it means '"'
//   - Following a '{' or '[', it means enter (newline)
//   - Following a digit, it means ','
//   - Following a comma or dot, it means space ' '

//
// Function
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |        |  F9  | F10  | F11  | F12  |      |        |      |      |      |      |      |        |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  F5  |  F6  |  F7  |  F8  |      |        |      | Shift| Ctrl |  Alt |  GUI |        |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  F1  |  F2  |  F3  |  F4  |      |        |      |      |      |      |      |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |      |      |      |  |      |      |      |
//                           `--------------------'  `--------------------'

//
// Navigation/Media
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |        |      |      |      |      | Bri+ |        | Vol+ | BkSp |   ↑  | Del  | PgUp |  Home  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  GUI |  Alt | Ctrl | Shift| Bri- |        | Vol- |  ←   |   ↓  |   →  | PgDn |   End  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |      |      |      |      |      |        | Mute |      |      |      |      |        |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |      |Numpad|      |  | Space|      | Enter|
//                           `--------------------'  `--------------------'
//

//
// Numpad -- Pressing Alt + Nav at the same time
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |        |      |      |      |      |      |        |      |   7  |   8  |   9  |   *  |  Bksp  |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |  GUI |  Alt | Ctrl | Shift|      |        |      |   4  |   5  |   6  |   -  |   +    |
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// |        |      |      |      |      |      |        |      |   1  |   2  |   3  |   /  | Magic  |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |      |      |      |  | Space|   0  |   .  |
//                           `--------------------'  `--------------------'
//
// * Magic has the same meaning as the symbol layer.


//
// Settings - pressing both Sym and Fn together.
//
// ,-------------------------------------------.        ,-------------------------------------------.
// |  USB L | BLE1 | BLE2 | BLE3 | BLE4 | USB R|        |Speed+|      |Brght+| Sat+ | Hue+ |HueSprd+|
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// | TxPwr+ |SplPw+|Embedd|Gemini|TxBolt|PloHID|        |Speed-|      |Brght-| Sat- | Hue- |HueSprd-|
// |--------+------+------+------+------+------|        |------+------+------+------+------+--------|
// | TxPwr- |SplPw-| WPM  | Tape |Strkes| D/UP |        |      |      |      |      |      | LAYOUT |
// `----------------------+--+---+--+---+--+---+--.  ,--+---+--+---+--+---+-------------------------'
//                           |      |      |      |  |      |      |      |
//                           `--------------------'  `--------------------'
//
// D/UP: Disconnects the active profile's bluetooth connection if connected.
//       Unpairs the profile if not connected.
//
// To pair a device to slot 1, hold BLE1 for 2 seconds. Same for BLE2-BLE4.

//---------------------------------------------------------------------------
// USB Scan code values.
//
// These constants are used with inbuilt functions:
//  * func pressScanCode(SC_xxx)
//  * func releaseScanCode(SC_xxx)
//  * func tapScanCode(SC_xxx)
//  * func isScanCodePressed(SC_xxx) var
//
//---------------------------------------------------------------------------

const SC_NONE = 0;

const SC_A = 0x04;
const SC_B = 0x05;
const SC_C = 0x06;
const SC_D = 0x07;
const SC_E = 0x08;
const SC_F = 0x09;
const SC_G = 0x0a;
const SC_H = 0x0b;
const SC_I = 0x0c;
const SC_J = 0x0d;
const SC_K = 0x0e;
const SC_L = 0x0f;
const SC_M = 0x10;
const SC_N = 0x11;
const SC_O = 0x12;
const SC_P = 0x13;
const SC_Q = 0x14;
const SC_R = 0x15;
const SC_S = 0x16;
const SC_T = 0x17;
const SC_U = 0x18;
const SC_V = 0x19;
const SC_W = 0x1a;
const SC_X = 0x1b;
const SC_Y = 0x1c;
const SC_Z = 0x1d;

const SC_1 = 0x1e;
const SC_2 = 0x1f;
const SC_3 = 0x20;
const SC_4 = 0x21;
const SC_5 = 0x22;
const SC_6 = 0x23;
const SC_7 = 0x24;
const SC_8 = 0x25;
const SC_9 = 0x26;
const SC_0 = 0x27;

const SC_ENTER = 0x28;
const SC_ESC = 0x29;
const SC_BACKSPACE = 0x2a;
const SC_TAB = 0x2b;
const SC_SPACE = 0x2c;
const SC_MINUS = 0x2d;
const SC_EQUAL = 0x2e;
const SC_L_BRACKET = 0x2f;
const SC_R_BRACKET = 0x30;
const SC_BACKSLASH = 0x31;
const SC_HASH_TILDE = 0x32;
const SC_SEMICOLON = 0x33;
const SC_APOSTROPHE = 0x34;
const SC_GRAVE = 0x35;
const SC_COMMA = 0x36;
const SC_DOT = 0x37;
const SC_SLASH = 0x38;
const SC_CAPS = 0x39;

const SC_F1 = 0x3a;
const SC_F2 = 0x3b;
const SC_F3 = 0x3c;
const SC_F4 = 0x3d;
const SC_F5 = 0x3e;
const SC_F6 = 0x3f;
const SC_F7 = 0x40;
const SC_F8 = 0x41;
const SC_F9 = 0x42;
const SC_F10 = 0x43;
const SC_F11 = 0x44;
const SC_F12 = 0x45;

const SC_SYS_RQ = 0x46;
const SC_SCROLL_LOCK = 0x47;
const SC_PAUSE = 0x48;
const SC_INSERT = 0x49;
const SC_HOME = 0x4a;
const SC_PAGE_UP = 0x4b;
const SC_DELETE = 0x4c;
const SC_END = 0x4d;
const SC_PAGE_DOWN = 0x4e;
const SC_RIGHT = 0x4f;
const SC_LEFT = 0x50;
const SC_DOWN = 0x51;
const SC_UP = 0x52;

const SC_NUM_LOCK = 0x53;
const SC_KP_SLASH = 0x54;
const SC_KP_ASTERISK = 0x55;
const SC_KP_MINUS = 0x56;
const SC_KP_PLUS = 0x57;
const SC_KP_ENTER = 0x58;
const SC_KP_1 = 0x59;
const SC_KP_2 = 0x5a;
const SC_KP_3 = 0x5b;
const SC_KP_4 = 0x5c;
const SC_KP_5 = 0x5d;
const SC_KP_6 = 0x5e;
const SC_KP_7 = 0x5f;
const SC_KP_8 = 0x60;
const SC_KP_9 = 0x61;
const SC_KP_0 = 0x62;
const SC_KP_DOT = 0x63;

const SC_BACKSLASH_PIPE = 0x64;
const SC_COMPOSE = 0x65;
const SC_POWER = 0x66;
const SC_KP_EQUAL = 0x67;

const SC_F13 = 0x68;
const SC_F14 = 0x69;
const SC_F15 = 0x6a;
const SC_F16 = 0x6b;
const SC_F17 = 0x6c;
const SC_F18 = 0x6d;
const SC_F19 = 0x6e;
const SC_F20 = 0x6f;
const SC_F21 = 0x70;
const SC_F22 = 0x71;
const SC_F23 = 0x72;
const SC_F24 = 0x73;

const SC_OPEN = 0x74;
const SC_HELP = 0x75;
const SC_MENU = 0x76;
const SC_SELECT = 0x77;
const SC_STOP = 0x78;
const SC_AGAIN = 0x79;
const SC_UNDO = 0x7a;
const SC_CUT = 0x7b;
const SC_COPY = 0x7c;
const SC_PASTE = 0x7d;
const SC_FIND = 0x7e;
const SC_MUTE = 0x7f;
const SC_VOLUME_UP = 0x80;
const SC_VOLUME_DOWN = 0x81;
const SC_KP_COMMA = 0x85;

const SC_L_CTRL = 0xe0;
const SC_L_SHIFT = 0xe1;
const SC_L_ALT = 0xe2;
const SC_L_META = 0xe3;
const SC_R_CTRL = 0xe4;
const SC_R_SHIFT = 0xe5;
const SC_R_ALT = 0xe6;
const SC_R_META = 0xe7;

// From Consumer Page (0x0c)
const SC_CONSUMER_PLAY = 0xa0;                // UsageId 0xb0
const SC_CONSUMER_PAUSE = 0xa1;               // UsageId 0xb1
const SC_CONSUMER_RECORD = 0xa2;              // UsageId 0xb2
const SC_CONSUMER_FAST_FORWARD = 0xa3;        // UsageId 0xb3
const SC_CONSUMER_REWIND = 0xa4;              // UsageId 0xb4
const SC_CONSUMER_SCAN_NEXT_TRACK = 0xa5;     // UsageId 0xb5
const SC_CONSUMER_SCAN_PREVIOUS_TRACK = 0xa6; // UsageId 0xb6
const SC_CONSUMER_STOP = 0xa7;                // UsageId 0xb7
const SC_CONSUMER_EJECT = 0xa8;               // UsageId 0xb8

const SC_CONSUMER_STOP_EJECT = 0xbc;          // UsageId 0xcc
const SC_CONSUMER_PLAY_PAUSE = 0xbd;          // UsageId 0xcd
const SC_CONSUMER_PLAY_SKIP = 0xbe;           // UsageId 0xce

const SC_CONSUMER_MUTE = 0xd2;                // UsageId 0xe2
const SC_CONSUMER_VOLUME_UP = 0xd9;           // UsageId 0xe9
const SC_CONSUMER_VOLUME_DOWN = 0xda;         // UsageId 0xea

const SC_CONSUMER_BRIGHTNESS_UP = 0xde;       // UsageId 0x6f
const SC_CONSUMER_BRIGHTNESS_DOWN = 0xdf;     // UsageId 0x70

//---------------------------------------------------------------------------
// javelin-steno steno key values.
//
// These constants are used with inbuilt functions:
//  * func pressStenoKey(SK_xxx)
//  * func releaseStenoKey(SK_xxx)
//  * func isStenoKeyPressed(SK_xxx) var
//
//---------------------------------------------------------------------------

const SK_NONE = -1;
const SK_S1 = 0;
const SK_S2 = 1;
const SK_TL = 2;
const SK_KL = 3;
const SK_PL = 4;
const SK_WL = 5;
const SK_HL = 6;
const SK_RL = 7;
const SK_A = 8;
const SK_O = 9;
const SK_STAR1 = 10;
const SK_STAR2 = 11;
const SK_STAR3 = 12;
const SK_STAR4 = 13;
const SK_E = 14;
const SK_U = 15;
const SK_FR = 16;
const SK_RR = 17;
const SK_PR = 18;
const SK_BR = 19;
const SK_LR = 20;
const SK_GR = 21;
const SK_TR = 22;
const SK_SR = 23;
const SK_DR = 24;
const SK_ZR = 25;
const SK_NUM1 = 26;
const SK_NUM2 = 27;
const SK_NUM3 = 28;
const SK_NUM4 = 29;
const SK_NUM5 = 30;
const SK_NUM6 = 31;
const SK_NUM7 = 32;
const SK_NUM8 = 33;
const SK_NUM9 = 34;
const SK_NUM10 = 35;
const SK_NUM11 = 36;
const SK_NUM12 = 37;
const SK_FUNCTION = 38;
const SK_POWER = 39;
const SK_RES1 = 40;
const SK_RES2 = 41;

//---------------------------------------------------------------------------
// Other functions:
//
//  * func releaseAll()
//    - releases all pressed scan codes and steno keys. This does NOT call
//      any release scripts.
//  * func pressAll()
//    - call all press scripts for buttons that are pressed.
//  * func isInPressAll() var
//    - returns non-zero if a pressAll is being processed.
//  * func isButtonPressed(buttonIndex) var
//    - Returns 1 if the physical button is pressed.
//  * func checkButtonState("01 10") var
//    - Returns if the current button state matches the string.
//    - 0 = not pressed, space = ignore, all others = pressed.
//      - The example string checks that:
//        - button 0 is off.
//        - button 1 is on.
//        - button 3 is on.
//        - button 4 is off.
//    - The string should be the same length as the number of buttons.
//  * func sendText("Example")
//    - Sends all of the key presses required to emit the specified string.
//    - e.g.,
//      - Press Shift
//      - Press E
//      - Release E
//      - Release Shift
//      - Press X
//      - Release X
//      - etc.
//  * func setRgb(id, r, g, b)
//    - For boards with rgb lights, sets an individual light to the r, g, b.
//  * func setHsv(id, h, s, v)
//    - For boards with rgb lights, sets an individual light to h, s, v.
//      - h = hue,        0-65536 represents 0°  - 360°
//      - s = saturation, 0-256   represents 0.0 - 1.0
//      - v = value,      0-255   represents 0.0 - 1.0
//  * func getTime() var
//    - Returns milliseconds since launch.
//  * func getLedStatus(id) var
//    - Returns whether the led statues is on. See LED_STATUS constants.
//
// releaseAll() and pressAll() are useful for changing modes/layers, e.g.:
//
// if (layer != SYMBOL_LAYER) {
//   releaseAll();
//   layer = SYMBOL_LAYER;
//   pressAll();
// }
//
// This will allow keys on the symbol layer to be pressed 'out-of-order' but
// still behave as expected.
//
// It is important that every pressAll() call in an onPress handler is guarded
// to prevent infinite recursion, since the onPress will be re-run even for the
// current key. The easiest way to do this is using isInPressAll() function.
//

const LED_STATUS_NUM_LOCK = 0;
const LED_STATUS_CAPS_LOCK = 1;
const LED_STATUS_SCROLL_LOCK = 2;
const LED_STATUS_COMPOSE = 3;
const LED_STATUS_KANA = 4;

//---------------------------------------------------------------------------
// Drawing methods:
//  * func clearDisplay(displayId)
//  * func setAutoDraw(displayId, autoDrawId)
//  * func setDrawColor(displayId, color)
//  * func drawPixel(displayId, x, y)
//  * func drawLine(displayId, x1, y1, x2, y2)
//  * func drawRect(displayId, left, top, right, bottom)
//  * func drawImage(displayId, x, y, image)
//  * func drawText(displayId, x, y, fontId, alignment, text)

const AUTO_DRAW_NONE = 0;
const AUTO_DRAW_PAPER_TAPE = 1;
const AUTO_DRAW_STENO_LAYOUT = 2;
const AUTO_DRAW_WPM = 3;
const AUTO_DRAW_STROKES = 4;

const TEXT_ALIGNMENT_LEFT = 0;
const TEXT_ALIGNMENT_MIDDLE = 1;
const TEXT_ALIGNMENT_RIGHT = 2;

const FONT_ID_NORMAL = 0;
const FONT_ID_SMALL_DIGITS = 1;
const FONT_ID_MEDIUM_DIGITS = 2;
const FONT_ID_LARGE_DIGITS = 3;

//---------------------------------------------------------------------------

const CONNECTION_NONE = 0;
const CONNECTION_BLE = 1;
const CONNECTION_USB = 2;
const CONNECTION_USB2 = 3;

const PAIR_CONNECTION_NONE = 0;
const PAIR_CONNECTION_BLE = 1;
const PAIR_CONNECTION_CABLE = 2;

const INPUT_HINT_KEYBOARD = 0;
const INPUT_HINT_STENOGRAPHY = 1;

const SCRIPT_ID_DISPLAY_OVERLAY = 0;
const SCRIPT_ID_BATTERY_UPDATE = 1;
const SCRIPT_ID_CONNECTION_UPDATE = 2;
const SCRIPT_ID_PAIR_CONNECTION_UPDATE = 3;
const SCRIPT_ID_KEYBOARD_LED_STATUS_UPDATE = 4;
const SCRIPT_ID_BLE_ADVERTISING_UPDATE = 5;
const SCRIPT_ID_BLE_SCANNING_UPDATE = 6;
const SCRIPT_ID_U2F_STATUS_UPDATE = 7;
const SCRIPT_ID_STENO_MODE_UPDATE = 9;

//---------------------------------------------------------------------------
//
// Corne button layout:
//
// Button indexes
//
//      0   1   2   3   4   5    |     6   7   8   9  10  11
//     12  13  14  15  16  17    |    18  19  20  21  22  23
//     24  25  26  27  28  29    |    30  31  32  33  34  35
//                   36  37  38  |  39  40  41
//
//
//---------------------------------------------------------------------------
// Example global variable:
//   var layers = 0;

// Example local functions:
//
//   func useNavLayer() var {
//     return isButtonPressed(22);
//   }
//
//   func handlePress(stenoKey, navKey) {
//     if (useNavLayer()) {
//       pressScanCode(navKey);
//     } else {
//       pressStenoKey(stenoKey);
//     }
//   }
//
// Then the onPress handler could call handlePress(SK_S1 | KEY_STENO, SC_TAB);

//---------------------------------------------------------------------------

// Constants passed in from the firmware.
const DISPLAY_WIDTH = JAVELIN_DISPLAY_WIDTH ?? 32;
const DISPLAY_HEIGHT = JAVELIN_DISPLAY_HEIGHT ?? 128;
const HAS_DISPLAY = JAVELIN_HAS_DISPLAY ?? 0;
const HAS_BLE = JAVELIN_HAS_BLE ?? 0;
const HAS_U2F = JAVELIN_HAS_U2F ?? 0;

// Inferred

const USE_STATUS_BAR = HAS_DISPLAY && HAS_BLE;
const USE_SCREEN_SAVER = HAS_DISPLAY;
const ENABLE_BLE_TRANSMIT_POWER_CONTROLS = HAS_BLE && 0;

//---------------------------------------------------------------------------
// The script needs to have onPress## and onRelease## functions for every
// physical button.
//---------------------------------------------------------------------------

const ALPHABETIC_LAYER = 0;
const STENO_MASK = 1;
const SYMBOL_MASK = 2;
const FUNCTION_MASK = 4;
const NAV_MASK = 8;
const NUMPAD_MASK = 16;
const TEMPORARY_QWERTY_MASK = 32;

var layer = STENO_MASK;
var pressCount = 0;
var speed = 1;
var hueSpread = 4;
var hueShift = 0;
var brightness = 3;
var saturation = 5;

var keyColorData[42];

// Fuzzy layers
//
// To avoid unintended navigation/function layer presses, the following
// sequence of events is interpreted as a press on the qwerty layer instead:
//
//     Layer key press        Key press        Layer key release
//            |                   |                     |
//   t ---------------------------------------------------------->
//           T0                  T1                    T2
//
// For this to happen, the time between T0 and T1 has to be less than 100 ms,
// and the time between T1 and T2 has to be less than 50 ms.
//
// Mechanics:
//  1. When a layer button is pressed, record a layerPressTimestamp.
//  2. When a key is pressed within 100ms and there is no recorded
//     keypress, then the layer and qwerty key are recorded. If there is
//     already a recorded keypress, press the deferred layer key and
//     immediately press the newer key. If a keypress occurs outside of 100ms,
//     process normally.
//  2. When the layer button is released, if there is a deferredAlphabeticKey
//     recorded timestamp within 50ms, then press the deferredAlphabeticKey then
//     the non-nav key. This is detected in release when NAV_MASK is on,
//     but isButtonPressed(38) returns false, and the key is emitted in the
//     release script for the layer key.
//  3. When a key is released, if there is a deferred key, press it first.
//  4. On timer expiration (after 50ms has elapsed), issue deferredAlphabeticKey.
const LAYER_PRESS_TO_KEY_PRESS_THRESHOLD = 100;
const KEY_PRESS_TO_LAYER_RELEASE_THRESHOLD = 50;
const NAV_BUTTON = 38;
const FUNCTION_BUTTON = 40;

var deferredLayerKey = 0;
var deferredAlphabeticKey = 0;
var navLayerPressTimestamp;
var functionLayerPressTimestamp;
var qwertyPressTimestamp;

const KEY_STENO = 0x200;
const KEY_SHIFT = 0x100;
const TAP_THRESHOLD = 200; // milliseconds for keys that have alternates
const RELEASE_TO_TAP_THRESHOLD = 200;
const SCREEN_SAVER_TIMEOUT = 900000; // 15 minutes.

const STENO_DISPLAY_WPM = 0;
const STENO_DISPLAY_PAPER_TAPE = 1;
const STENO_DISPLAY_STROKES_WPM = 2;

const TIMER_ID_RGB_UPDATE = 0;
const TIMER_ID_FUZZY_LAYER = 1;
const TIMER_ID_SCREEN_SAVER = 2;
const TIMER_ID_PAIRING_HOLD = 3;
const TIMER_ID_CAPS_HOLD = 4;
const TIMER_ID_CAPS_RELEASE = 5;

var stenoDisplay = STENO_DISPLAY_WPM;
var wordCaps = 0;
var lastPressLayer;
var lastPressKey;

var isBleSummaryActive;
func isShowingBleSummary() var {
  return isSettingsLayer() && isBleSummaryActive;
}

const ALPHABETIC_LAYOUT_QWERTY = 0;
const ALPHABETIC_LAYOUT_DVORAK = 1;
const ALPHABETIC_LAYOUT_COLEMAK = 2;
const ALPHABETIC_LAYOUT_WORKMAN = 3;
const ALPHABETIC_LAYOUT_COLEMAK_DH = 4;

const ALPHABETIC_LAYOUT_COUNT = 5;

// Change this line to set the default layout on startup.
var alphabeticLayout = ALPHABETIC_LAYOUT_QWERTY;

const buttonScanCodes = [[
  2b 2b 2b 2b 2b  // Button 0: Tab
  14 34 14 14 14  // Button 1: Q, Apos, Q, Q, Q
  1a 36 1a 07 1a  // Button 2: W, Comma, W, D, W
  08 37 09 15 09  // Button 3: E, Period, F, R, F
  15 13 13 1a 13  // Button 4: R, P, P, W, P
  17 1c 0a 05 05  // Button 5: T, Y, G, B, B
  1c 09 0d 0d 0d  // Button 6: Y, F, J, J, J
  18 0a 0f 09 0f  // Button 7: U, G, L, F, L
  0c 06 18 18 18  // Button 8: I, C, U, U, U
  12 15 1c 13 1c  // Button 9: O, R, Y, P, Y
  13 0f 33 33 33  // Button 10: P, L, Semicolon, Semicolon, Semicolon
  2a 2a 2a 2a 2a  // Button 11: Backspace
  e0 e0 e0 e0 e0  // Button 12: Ctrl
  04 04 04 04 04  // Button 13: A
  16 12 15 16 15  // Button 14: S, O, R, S, R
  07 08 16 0b 16  // Button 15: D, E, S, H, S
  09 18 17 17 17  // Button 16: F, U, T, T, T
  0a 0c 07 0a 0a  // Button 17: G, I, D, G, G
  0b 07 0b 1c 10  // Button 18: H, D, H, Y, M
  0d 0b 11 11 11  // Button 19: J, H, N, N, N
  0e 17 08 08 08  // Button 20: K, T, E, E, E
  0f 11 0c 12 0c  // Button 21: L, N, I, O, I
  33 16 12 0c 12  // Button 22: Semicolon, S, O, I, O
  34 2d 34 34 34  // Button 23: Apos, Minus, Apos, Apos, Apos
  00 00 00 00 00  // Button 24: <Special cased shift/steno>
  1d 33 1d 1d 1d  // Button 25: Z, Semicolon, Z, Z, Z
  1b 14 1b 1b 1b  // Button 26: X, Q, X, X, X
  06 0d 06 10 06  // Button 27: C, J, C, M, C
  19 0e 19 06 07  // Button 28: V, K, V, C, D
  05 1b 05 19 19  // Button 29: B, X, B, V, V
  11 05 0e 0e 0e  // Button 30: N, B, K, K, K
  10 10 10 0f 0b  // Button 31: M, M, M, L, H
  36 1a 36 36 36  // Button 32: Comma, W, Comma, Comma, Comma
  37 19 37 37 37  // Button 33: Period, V, Period, Period, Period
  38 1d 38 38 38  // Button 34: Slash, Z, Slash, Slash, Slash
  e5 e5 e5 e5 e5  // Button 35: Right Shift
  e3 e3 e3 e3 e3  // Button 36: Meta (Command, Windows)
  e2 e2 e2 e2 e2  // Button 37: Alt
  00 00 00 00 00  // Button 38: <Special case navigation/space>
  2c 2c 2c 2c 2c  // Button 39: Space
  00 00 00 00 00  // Button 40: <Special case Symbol>
  00 00 00 00 00  // Button 41: <Special case Function/Enter>
]];

const SHIFT_IMAGE = [[
  10 10
  00 01 80 01 c0 01 e0 01 f0 7f f8 7f fc 7f fe 7f
  fe 7f fc 7f f8 7f f0 7f e0 01 c0 01 80 01 00 01
]];

const CONTROL_IMAGE = [[
  10 10
  00 00 00 00 40 00 60 00 30 00 18 00 0c 00 06 00
  06 00 0c 00 18 00 30 00 60 00 40 00 00 00 00 00
]];

const ALT_IMAGE = [[
  10 10
  00 00 00 30 00 30 00 30 00 30 00 38 00 1e 80 07
  e0 01 78 30 1c 30 0c 30 0c 30 0c 30 0c 30 00 00
]];

const COMMAND_IMAGE = [[
  10 10
  00 00 3c 3c 7e 7e 66 66 66 66 fe 7f fc 3f 60 06
  60 06 fc 3f fe 7f 66 66 66 66 7e 7e 3c 3c 00 00
]];

const CAPS_LOCK_IMAGE = [[
  10 10
  00 01 80 01 c0 01 e0 01 f0 67 f8 67 fc 67 fe 67
  fe 67 fc 67 f8 67 f0 67 e0 01 c0 01 80 01 00 01
]];

const STENO_IMAGE = [[
  20 20 ff ff 3f 00 ff ff ff 00 ff ff ff 03 ff ff
  ff 07 ff ff ff 0f ff ff ff 1f ff f9 f3 3f ff f0
  e1 3f ff f0 e1 7f ff e1 f0 7f ff e3 f8 ff ff 47
  fc ff ff 07 fc ff ff 0f fe ff 0f 00 00 fe 0f 00
  00 fe 0f 00 00 fe ff 0f fe ff ff 07 fc ff ff 47
  fc ff ff e3 f8 ff ff e1 f0 7f ff f0 e1 7f ff f0
  e1 3f ff f9 f3 3f ff ff ff 1f ff ff ff 0f ff ff
  ff 07 ff ff ff 03 ff ff ff 00 ff ff 3f 00 00 00
  00 00
]];

const FUNCTION_IMAGE = [[
  20 20
  f0 ff ff 0f f8 ff ff 1f 0c 00 00 30 06 00 00 60
  03 00 00 c0 03 00 06 c0 03 00 06 c0 03 c0 ff c7
  03 e0 ff c7 03 60 06 c0 03 60 06 c0 03 00 00 c0
  03 00 fe c7 03 00 fe c7 03 00 0c c0 03 00 06 c0
  03 00 0e c0 03 00 fc c7 03 00 f8 c7 03 00 00 c0
  03 00 00 c0 03 00 00 c0 03 00 00 c0 03 00 00 c0
  03 00 00 c0 03 00 00 c0 03 00 00 c0 03 00 00 c0
  06 00 00 60 0c 00 00 30 f8 ff ff 1f f0 ff ff 0f
]];

const QWERTY_IMAGE = [[
  20 20 00 00 00 00 00 00 08 00 00 00 0c 00 00 00
  0f 00 00 c0 0f 00 00 f0 09 00 00 bc 00 00 80 8f
  00 00 80 bf 00 00 00 fc 08 00 00 f0 0f 00 00 c0
  0f 00 00 00 0e 00 00 00 08 00 80 00 08 00 80 ff
  0f 00 80 ff 0f 00 00 30 0c 00 00 10 08 00 00 30
  0c 00 00 f0 0f 00 00 e0 07 00 00 00 00 00 00 e0
  07 00 00 f0 0f 00 00 30 0c 00 00 10 08 00 00 30
  0c 00 00 70 0e 00 00 60 06 00 00 00 00 00 00 00
  00 00
]];

const SYMBOL_IMAGE = [[
  20 20 00 00 00 00 00 00 00 00 18 00 00 00 18 00
  00 00 1c 00 00 00 fe 3f ff 1b fe 3f ff 1b fe 3f
  ff 1b 00 00 00 00 00 00 fc 0f 00 00 fe 1f 1c 38
  ff 3f 1e 3c 07 38 1e 3e f3 33 06 3f f3 37 86 37
  f3 37 c6 33 07 36 fe 31 ff 3b fe 30 fe 3b 3c 30
  fc 19 00 00 00 00 1c 0c 00 03 1e 1c 18 3f 1e 3c
  f8 3f c6 38 ff 3f c6 30 ff 03 e6 30 1f 3f fe 39
  f8 3f fe 3f ff 3f bc 1f ff 03 00 0e 1f 03 00 00
  18 00
]];

const NAVIGATION_IMAGE = [[
  20 20 00 00 00 00 00 80 01 00 00 c0 03 00 00 e0
  07 00 00 f0 0f 00 00 f8 1f 00 00 fc 3f 00 00 e0
  07 00 00 e0 07 00 00 e0 07 00 40 e0 07 02 60 e0
  07 06 70 00 00 0e f8 0f f0 1f fc 0f f0 3f fe 0f
  f0 7f fe 0f f0 7f fc 0f f0 3f f8 0f f0 1f 70 00
  00 0e 60 e0 07 06 40 e0 07 02 00 e0 07 00 00 e0
  07 00 00 e0 07 00 00 fc 3f 00 00 f8 1f 00 00 f0
  0f 00 00 e0 07 00 00 c0 03 00 00 80 01 00 00 00
  00 00
]];

const SETTINGS_IMAGE = [[
  20 20 00 00 00 00 00 c0 03 00 00 e0 07 00 00 e0
  07 00 c0 e0 07 03 e0 f3 cf 07 f0 ff ff 0f f0 ff
  ff 0f e0 ff ff 07 e0 ff ff 07 c0 ff ff 03 c0 7f
  fe 03 e0 1f f8 07 fc 0f f0 3f fe 0f f0 7f fe 07
  e0 7f fe 07 e0 7f fe 0f f0 7f fc 0f f0 3f e0 1f
  f8 07 c0 7f fe 03 c0 ff ff 03 e0 ff ff 07 e0 ff
  ff 07 f0 ff ff 0f f0 ff ff 0f e0 f3 cf 07 c0 e0
  07 03 00 e0 07 00 00 e0 07 00 00 c0 03 00 00 00
  00 00
]];

const NUMPAD_IMAGE = [[
  20 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00 7e 7e 7e 7e 7e 7e
  7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e
  7e 7e 00 00 00 7e 00 00 00 7e 7e 7e 7e 7e 7e 7e
  7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e
  7e 7e 00 00 00 00 00 00 00 00 7e 7e 7e 7e 7e 7e
  7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e 7e
  7e 7e 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00 00
]];

const SPEED_IMAGE = [[
  10 10 80 1f e0 3f f0 30 38 30 18 30 1c 30 0c 30
  0c 36 0c 37 8c 33 dc 31 d8 30 38 30 f0 30 e0 3f
  80 1f
]];

const BRIGHTNESS_IMAGE = [[
  10 10 80 01 86 61 8e 71 1c 38 d8 1b e0 07 70 0e
  37 ec 37 ec 70 0e e0 07 d8 1b 1c 38 8e 71 86 61
  80 01
]];

const CONTRAST_IMAGE = [[
  10 10 e0 07 f8 1f 3c 3c 0e 70 06 60 07 e0 03 c0
  03 c0 ff ff ff ff ff ff fe 7f fe 7f fc 3f f8 1f
  e0 07
]];

const HUE_SPREAD_IMAGE = [[
  10 10 e0 07 f8 1f 3c 3c 8e 71 c6 63 e7 e7 83 c1
  83 c1 ff ff 7f fe 7f fe 1e 78 3e 7c 7c 3e f8 1f
  e0 07
]];

const BAR_IMAGES = [[
  // BAR_000_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 00
  00 40 01 00 00 00 00 00 00 80 01 00 00 00 00 00
  00 80 01 00 00 00 00 00 00 80 01 00 00 00 00 00
  00 80 02 00 00 00 00 00 00 40 fc ff ff ff ff ff
  ff 3f

  // BAR_125_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 00
  00 7f 01 00 00 00 00 00 00 ff 01 00 00 00 00 00
  00 ff 01 00 00 00 00 00 00 ff 01 00 00 00 00 00
  00 ff 02 00 00 00 00 00 00 7f fc ff ff ff ff ff
  ff 3f

  // BAR_250_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 00
  ff 7f 01 00 00 00 00 00 ff ff 01 00 00 00 00 00
  ff ff 01 00 00 00 00 00 ff ff 01 00 00 00 00 00
  ff ff 02 00 00 00 00 00 ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_375_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 00 ff
  ff 7f 01 00 00 00 00 ff ff ff 01 00 00 00 00 ff
  ff ff 01 00 00 00 00 ff ff ff 01 00 00 00 00 ff
  ff ff 02 00 00 00 00 ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_500_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 00 ff ff
  ff 7f 01 00 00 00 ff ff ff ff 01 00 00 00 ff ff
  ff ff 01 00 00 00 ff ff ff ff 01 00 00 00 ff ff
  ff ff 02 00 00 00 ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_625_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 00 ff ff ff
  ff 7f 01 00 00 ff ff ff ff ff 01 00 00 ff ff ff
  ff ff 01 00 00 ff ff ff ff ff 01 00 00 ff ff ff
  ff ff 02 00 00 ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_750_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 00 ff ff ff ff
  ff 7f 01 00 ff ff ff ff ff ff 01 00 ff ff ff ff
  ff ff 01 00 ff ff ff ff ff ff 01 00 ff ff ff ff
  ff ff 02 00 ff ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_875_IMAGE
  08 40 fc ff ff ff ff ff ff 3f 02 ff ff ff ff ff
  ff 7f 01 ff ff ff ff ff ff ff 01 ff ff ff ff ff
  ff ff 01 ff ff ff ff ff ff ff 01 ff ff ff ff ff
  ff ff 02 ff ff ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f

  // BAR_1000_IMAGE
  08 40 fc ff ff ff ff ff ff 3f fe ff ff ff ff ff
  ff 7f ff ff ff ff ff ff ff ff ff ff ff ff ff ff
  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
  ff ff fe ff ff ff ff ff ff 7f fc ff ff ff ff ff
  ff 3f
]];

const EMBEDDED_IMAGE = [[
  20 10 00 00 00 00 61 00 81 00 81 4c 81 92 7f 92
  00 92 68 64 94 00 54 04 f8 fe 00 84 3c 00 c0 78
  3c a4 00 94 78 48 a4 00 94 fc 48 08 00 04 ff f8
  00 00 fd 78 00 84 fc 84 08 78 04 00 f8 00 00 00
  00 00
]];

const GEMINI_IMAGE = [[
  20 08 00 00 7e 81 81 91 72 00 78 a4 94 48 00 fc
  04 f8 04 f8 00 fd 00 fc 08 04 f8 00 fd 00 00 00
  00 00
]];

const PLOVER_HID_IMAGE = [[
  20 10 00 00 00 00 00 00 ff 00 11 00 11 00 0e 00
  00 00 ff 00 00 00 78 fe 84 10 84 10 78 fe 00 00
  3c fe c0 00 3c fe 00 82 78 82 a4 7c 94 00 48 00
  00 00 fc 00 08 00 04 00 08 00 00 00 00 00 00 00
  00 00
]];

const STROKES_IMAGE = [[
  20 08 4c 92 92 64 00 02 fe 02 00 fe 12 12 ec 00
  7c 82 82 7c 00 fe 10 28 c6 00 fe 92 82 00 4c 92
  92 64
]];

const PAIR_CONNECTED_STATUS_IMAGE_OFFSETS = [[ 00 02 1c ]];
const PAIR_CONNECTED_STATUS_IMAGES = [[
  // None
  00 00

  // BLE
  0c 0c 00 00 98 00 98 01 98 03 98 07 98 01 98 01
  9e 01 9c 01 98 01 90 01 00 00

  // Cable
  0c 0c 00 00 60 00 f0 00 f8 01 fc 03 f0 00 f0 00
  fc 03 f8 01 f0 00 60 00 00 00
]];

const USB_STATUS_IMAGE = [[
  09 0c 30 00 78 00 b0 00 06 0d ff 0f 86 0c 58 00
  3c 00 18 00
]];

const BLUETOOTH_STATUS_IMAGE = [[
  06 0c 08 01 90 00 ff 0f 62 04 94 02 08 01
]];

const BATTERY_LEVEL_STATUS_IMAGES = [[
  // battery0
  0c 0c f8 01 08 01 08 01 08 01 08 01 08 01 08 01
  08 01 08 01 08 01 f8 01 f0 00

  // battery1
  0c 0c f8 01 f8 01 08 01 08 01 08 01 08 01 08 01
  08 01 08 01 08 01 f8 01 f0 00

  // battery2
  0c 0c f8 01 f8 01 f8 01 08 01 08 01 08 01 08 01
  08 01 08 01 08 01 f8 01 f0 00

  // battery3
  0c 0c f8 01 f8 01 f8 01 f8 01 08 01 08 01 08 01
  08 01 08 01 08 01 f8 01 f0 00

  // battery4
  0c 0c f8 01 f8 01 f8 01 f8 01 f8 01 08 01 08 01
  08 01 08 01 08 01 f8 01 f0 00

  // battery5
  0c 0c f8 01 f8 01 f8 01 f8 01 f8 01 f8 01 08 01
  08 01 08 01 08 01 f8 01 f0 00

  // battery6
  0c 0c f8 01 f8 01 f8 01 f8 01 f8 01 f8 01 f8 01
  08 01 08 01 08 01 f8 01 f0 00

  // battery7
  0c 0c f8 01 f8 01 f8 01 f8 01 f8 01 f8 01 f8 01
  f8 01 08 01 08 01 f8 01 f0 00

  // battery8
  0c 0c f8 01 f8 01 f8 01 f8 01 f8 01 f8 01 f8 01
  f8 01 f8 01 08 01 f8 01 f0 00

  // battery9
  0c 0c f8 01 f8 01 f8 01 f8 01 f8 01 f8 01 f8 01
  f8 01 f8 01 f8 01 f8 01 f0 00
]];

const CHARGING_STATUS_IMAGE = [[
  0c 0c f8 01 08 01 08 01 68 01 70 04 78 03 ec 01
  e2 00 68 01 08 01 f8 01 f0 00
]];

const RGB_UPDATE_TIME = 10;
const BLE_UPDATE_TIME = 50;

func init() {
  // Disable liatris power light.
  // setGpioPin(24, 1);

  if (USE_STATUS_BAR) {
    setScript(SCRIPT_ID_DISPLAY_OVERLAY, @drawDisplayOverlay);
  }
  setScript(SCRIPT_ID_BATTERY_UPDATE, @onBatteryUpdate);
  setScript(SCRIPT_ID_CONNECTION_UPDATE, @onConnectionUpdate);
  setScript(SCRIPT_ID_PAIR_CONNECTION_UPDATE, @onConnectionUpdate);
  setScript(SCRIPT_ID_KEYBOARD_LED_STATUS_UPDATE, @onKeyboardLedStatusUpdate);
  setScript(SCRIPT_ID_STENO_MODE_UPDATE, @onStenoModeUpdate);

  if (HAS_BLE) {
    setScript(SCRIPT_ID_BLE_ADVERTISING_UPDATE, @onConnectionUpdate);

    if (ENABLE_BLE_TRANSMIT_POWER_CONTROLS) {
      updateBleTransmitPower(4);
      updateBleSplitTransmitPower(4);
    }
  }

  if (HAS_U2F) {
    setScript(SCRIPT_ID_U2F_STATUS_UPDATE, @onU2fStatusUpdate);
  }

  updateAllButtonColors();

  setLayer(layer);
  updateScreenContrast();

  updateBoardPower();
  updateScreenSaverTimer();
}

// Uncomment this function when developing to ensure callbacks and timers
// work properly, otherwise they may call a wrong address in the script.
//
// func tick() {
//   if (USE_STATUS_BAR) {
//     setScript(SCRIPT_ID_DISPLAY_OVERLAY, @drawDisplayOverlay);
//   }
//   setScript(SCRIPT_ID_BATTERY_UPDATE, @onBatteryUpdate);
//   setScript(SCRIPT_ID_CONNECTION_UPDATE, @onConnectionUpdate);
//   setScript(SCRIPT_ID_PAIR_CONNECTION_UPDATE, @onConnectionUpdate);
//   setScript(SCRIPT_ID_KEYBOARD_LED_STATUS_UPDATE, @onKeyboardLedStatusUpdate);
//
//   if (HAS_BLE) {
//     setScript(SCRIPT_ID_BLE_ADVERTISING_UPDATE, @onConnectionUpdate);
//   }
//
//   updateBoardPower();
// }


func shouldUseScreenSaver() var {
  if (HAS_BLE && getActivePairConnection() == PAIR_CONNECTION_BLE) {
    return isPairPowered() && isMainPowered();
  } else {
    // No pair, or cable pair.
    return isPairPowered() || isMainPowered();
  }
}

var isShowingScreenSaver = 0;
var screenSaverStartTime;
var screenSaverPosition[8];
var screenSaverVelocity[8];
func startScreenSaver() {
  if (!shouldUseScreenSaver()) return;

  setAutoDraw(0, AUTO_DRAW_NONE);
  setAutoDraw(1, AUTO_DRAW_NONE);

  isShowingScreenSaver = 1;
  screenSaverStartTime = getTime();
  for (var i = 0; i < 8; i = i + 2) {
    screenSaverPosition[i] = rand();
    screenSaverPosition[i + 1] = rand();
  }
  for (var i = 0; i < 8; i = i + 1) {
    var velocity = (rand() & 0x1ff) - 256;
    velocity = velocity + (velocity < 0 ? -32 : 32);
    screenSaverVelocity[i] = velocity;
  }
  drawScreenSaver();
  startTimer(TIMER_ID_SCREEN_SAVER, 50, 1, @drawScreenSaver);
}

func wrap(x, max) var {
  x = x % (2 * max);
  if (x < 0) x = -x;
  return x < max ? x : 2 * max - x;
}

const OVERLAY_HEIGHT = 16;

func drawScreenSaver() {
  var timeElapsed = getTime() - screenSaverStartTime;

  for (var display = 0; display < 2; display = display + 1) {
    var index = 4 * display;
    clearDisplay(display);

    for (var i = 0; i < 5; i = i + 1) {
      var effectiveTime = timeElapsed + i * 100;
      drawLine(
        display,
        wrap(screenSaverPosition[index    ] + (effectiveTime * screenSaverVelocity[index    ] >> 13), DISPLAY_WIDTH),
        wrap(screenSaverPosition[index + 1] + (effectiveTime * screenSaverVelocity[index + 1] >> 13), DISPLAY_HEIGHT - OVERLAY_HEIGHT) + OVERLAY_HEIGHT,
        wrap(screenSaverPosition[index + 2] + (effectiveTime * screenSaverVelocity[index + 2] >> 13), DISPLAY_WIDTH),
        wrap(screenSaverPosition[index + 3] + (effectiveTime * screenSaverVelocity[index + 3] >> 13), DISPLAY_HEIGHT - OVERLAY_HEIGHT) + OVERLAY_HEIGHT,
      );
    }
  }
}

func updateScreenSaverTimer() {
  if (!USE_SCREEN_SAVER) return;

  if (isShowingScreenSaver) {
    isShowingScreenSaver = 0;
    updateDisplay0();
  }
  startTimer(TIMER_ID_SCREEN_SAVER, SCREEN_SAVER_TIMEOUT, 1, @startScreenSaver);
}

const BLE_PROFILE_DOTS = [[
  02 10 c0 00 c0 00
  02 10 b0 01 b0 01
  02 10 d8 06 d8 06
  02 10 b6 0d b6 0d
]];
func drawDisplayOverlay() {
  if (!HAS_DISPLAY) return;

  // Clear the region.
  setDrawColor(0, 0);
  drawRect(0, 0, 0, DISPLAY_WIDTH, OVERLAY_HEIGHT);
  setDrawColor(0, 1);

  drawImage(
    0,
    2, 2,
    PAIR_CONNECTED_STATUS_IMAGES
      + PAIR_CONNECTED_STATUS_IMAGE_OFFSETS[getActivePairConnection()]
  );

  var x = 15;
  var activeConnection = getActiveConnection();
  var activeConnectionCount = 0;
  var activeConnectionPosition;
  var activeConnectionUnderlineLength;
  if (isConnected(CONNECTION_USB)) {
    drawImage(0, x, 1, USB_STATUS_IMAGE);
    if (activeConnection == CONNECTION_USB) {
      activeConnectionPosition = x;
      activeConnectionUnderlineLength = 9;
    }
    activeConnectionCount = activeConnectionCount + 1;
    x = x + 11;
  }
  if (isConnected(CONNECTION_BLE)) {
    drawImage(0, x+2, 1, BLUETOOTH_STATUS_IMAGE);
    if (activeConnection == CONNECTION_BLE) {
      activeConnectionPosition = x;
      activeConnectionUnderlineLength = 13;
    }

    drawImage(0, x+9, 0, BLE_PROFILE_DOTS + 6*getBleProfile());

    activeConnectionCount = activeConnectionCount + 1;
    x = x + 15;
  }
  if (isConnected(CONNECTION_USB2)) {
    drawImage(0, x, 1, USB_STATUS_IMAGE);
    if (activeConnection == CONNECTION_USB2) {
      activeConnectionPosition = x;
      activeConnectionUnderlineLength = 9;
    }
    activeConnectionCount = activeConnectionCount + 1;
    // x = x + 11;
  }

  if (activeConnectionCount > 1) {
    drawRect(0,
             activeConnectionPosition,
             14,
             activeConnectionPosition+activeConnectionUnderlineLength,
             16);
  }

  if (isMainPowered()) {
    if (isCharging()) {
      drawImage(0, DISPLAY_WIDTH-14, 0, CHARGING_STATUS_IMAGE);
    }
  } else {
    // Map 0-100 -> 0-9.
    // (value * 9 + 50) / 100
    var batteryIndex = (getBatteryPercentage() * 9 + 50) / 100;
    drawImage(0, DISPLAY_WIDTH-14, 0, BATTERY_LEVEL_STATUS_IMAGES + batteryIndex * 26);
  }
}

func redrawDisplayOverlay() {
  if (!HAS_DISPLAY) return;

  // Mark the screen dirty
  drawRect(0, 0, 0, 0, 0);
}

func updateBoardPower() {
  if (HAS_U2F && isWaitingForUserPresence()) {
    startTimer(TIMER_ID_RGB_UPDATE, 32, 1, @updateKeyRgb);
    setBoardPower(1);
  } else if (HAS_BLE && isBleAdvertising()) {
    startTimer(TIMER_ID_RGB_UPDATE, 32, 1, @updateKeyRgb);
    setBoardPower(1);
  } else if (brightness == 0) {
    stopTimer(TIMER_ID_RGB_UPDATE);
    setBoardPower(getActivePairConnection() == PAIR_CONNECTION_CABLE);
  } else if (HAS_BLE && getActivePairConnection() == PAIR_CONNECTION_BLE) {
    if (isPairPowered() && isMainPowered()) {
      startTimer(TIMER_ID_RGB_UPDATE, BLE_UPDATE_TIME, 1, @updateKeyRgb);
    } else {
      stopTimer(TIMER_ID_RGB_UPDATE);
    }
    setBoardPower(isMainPowered());
  } else {
    // No pair, or cable pair.
    if (isPairPowered() || isMainPowered()) {
      startTimer(TIMER_ID_RGB_UPDATE, RGB_UPDATE_TIME, 1, @updateKeyRgb);
      setBoardPower(1);
    } else {
      stopTimer(TIMER_ID_RGB_UPDATE);
      setBoardPower(0);
    }
  }
  updateKeyRgb();
  updateUnderglowRgb();
}

func onBatteryUpdate() {
  redrawDisplayOverlay();
  updateBoardPower();
}

func onConnectionUpdate() {
  if (HAS_BLE && isShowingBleSummary()) {
    drawBleSummary();
  }
  redrawDisplayOverlay();
  updateBoardPower();
}

func onU2fStatusUpdate() {
  updateBoardPower();
}

func onKeyboardLedStatusUpdate() {
  updateKeyRgb();
  if (HAS_DISPLAY) {
    if (HAS_BLE && isShowingBleSummary()) {
      drawBleSummary();
    } else {
      updateDisplay0();
    }
  }
}

func onStenoModeUpdate() {
  if (HAS_DISPLAY) {
    if (HAS_BLE && isShowingBleSummary()) {
      drawBleSummary();
    } else {
      updateDisplay0();
    }
  }
}

const HUE_CYCLE_RGB_ORDER = [[
  00
  0c 01
  18 0d 02
  19 0e 03
  1a 0f 04
  1b 10 05
  24 1c 11
  25 1d
  26

  27
  28 1e
  29 1f 12
  20 13 06
  21 14 07
  22 15 08
  23 16 09
  17 0a
  0b
]];

const SPEED_VALUES      = [[ 00 04 08 0c 10 18 20 30 40 ]];
const HUE_SPREAD_VALUES = [[ 00 10 20 28 30 38 40 48 50 ]];
const SATURATION_VALUES = [[ 00 20 40 50 60 68 70 78 80 ]];
const BRIGHTNESS_VALUES = [[ 00 08 10 20 40 60 80 c0 ff ]];

func updateKeyRgbHueCycle(hShift, sat, spreadMultiplier, value) {
  for (var i = 0; i < 42; i = i + 1) {
    setHsv(
      HUE_CYCLE_RGB_ORDER[i],
      spreadMultiplier*i + hShift,
      sat,
      value
    );
  }
}

func updateKeyRgbConstantColor(r, g, b) {
  for (var i = 0; i < 42; i = i + 1) {
    setRgb(i, r, g, b);
  }
}

func updateKeyRgbRandomColors(hShift, b, s) {
  var alwaysFullBrightness = !shouldShowKeyAnimations();
  for (var i = 0; i < 42; i = i + 1) {
    var v = keyColorData[i];
    if ((v >>> 24) < 32) {
      v = alwaysFullBrightness
            ? (v | 0x20000000)
            : (v + 0x1000000);
      keyColorData[i] = v;
    }
    setHsv(i, hShift + v, s, b * (v >>> 24) >> 5);
  }
}

// 256 step sine table.
const SINE_TABLE = [[ 80 83 86 89 8c 8f 92 95 98 9b 9e a2 a5 a7 aa ad b0 b3 b6 b9 bc be c1 c4 c6 c9 cb ce d0 d3 d5 d7 da dc de e0 e2 e4 e6 e8 ea eb ed ee f0 f1 f3 f4 f5 f6 f8 f9 fa fa fb fc fd fd fe fe fe ff ff ff ff ff ff ff fe fe fe fd fd fc fb fa fa f9 f8 f6 f5 f4 f3 f1 f0 ee ed eb ea e8 e6 e4 e2 e0 de dc da d7 d5 d3 d0 ce cb c9 c6 c4 c1 be bc b9 b6 b3 b0 ad aa a7 a5 a2 9e 9b 98 95 92 8f 8c 89 86 83 80 7c 79 76 73 70 6d 6a 67 64 61 5d 5a 58 55 52 4f 4c 49 46 43 41 3e 3b 39 36 34 31 2f 2c 2a 28 25 23 21 1f 1d 1b 19 17 15 14 12 11 0f 0e 0c 0b 0a 09 07 06 05 05 04 03 02 02 01 01 01 00 00 00 00 00 00 00 01 01 01 02 02 03 04 05 05 06 07 09 0a 0b 0c 0e 0f 11 12 14 15 17 19 1b 1d 1f 21 23 25 28 2a 2c 2f 31 34 36 39 3b 3e 41 43 46 49 4c 4f 52 55 58 5a 5d 61 64 67 6a 6d 70 73 76 79 7c ]];
func updateKeyRgbBreatheCycle() {
  // Sine wave between 4-20 brightness, with staggering of r, g, b values
  // to reduce harsh steps.
  var w = (0xc00 + (SINE_TABLE[(animationTime() >> 5) & 0xff] - 0x80) * (2 * 8));
  updateKeyRgbConstantColor((w + 0x53) >> 8, w >> 8, (w + 0xa6) >> 8);
}

const DISCONNECTED_KEY_ORDER = [[ 00 01 02 03 04 05 04 03 02 01 ]];
func updateKeyRgbConnectingCycle() {
  for (var i = 0; i < 54; i = i + 1) {
    setRgb(i, 0, 0, 0);
  }

  var index = getTime() >> 6;
  var keyId = DISCONNECTED_KEY_ORDER[index % 10];
  setHsv(keyId, index << 10, 0xf0, 16);
}

const U2F_KEY_ORDER = [[ 00 01 02 03 04 05 06 07 08 09 0a 0b 0a 09 08 07 06 05 04 03 02 01 ]];
func updateKeyRgbU2fAlertCycle() {
  for (var i = 0; i < 54; i = i + 1) {
    setRgb(i, 0, 0, 0);
  }

  var index = getTime() >> 6;
  var keyId = U2F_KEY_ORDER[index % 22];
  setRgb(keyId, 16, 16, 16);

  setRgb(12, 32, 0, 0);
  setRgb(24, 0, 32, 0);
  setRgb(35, 0, 32, 0);
  setRgb(36, 0, 32, 0);
  setRgb(37, 0, 32, 0);
  setRgb(40, 0, 32, 0);
}

func shouldShowKeyAnimations() var {
  var activePairConnection = getActivePairConnection();
  if (activePairConnection == PAIR_CONNECTION_NONE) {
    // To avoid flicker at startup while connecting to BLE
    // do not show button animations when disconnected.
    return 0;
  }

  if (activePairConnection == PAIR_CONNECTION_BLE) {
    // To avoid power drain over BLE, only show animations if
    // both sides are powered.
    return isMainPowered() && isPairPowered();
  }

  return isMainPowered() || isPairPowered();
}

func animationTime() var {
  return shouldShowKeyAnimations() ? getTime() : 0;
}

func updateKeyRgb() {
  if (HAS_U2F && isWaitingForUserPresence()) {
    updateKeyRgbU2fAlertCycle();
  } else if (HAS_BLE && isBleAdvertising()) {
    updateKeyRgbConnectingCycle();
  } else if (isHostSleeping()) {
    updateKeyRgbBreatheCycle();
  } else if (layer == STENO_MASK) {
    updateKeyRgbHueCycle(
      animationTime() * SPEED_VALUES[speed] + hueShift,
      SATURATION_VALUES[saturation] * 2,
      HUE_SPREAD_VALUES[hueSpread] * 16,
      BRIGHTNESS_VALUES[brightness]
    );
  } else {
    updateKeyRgbRandomColors(
      animationTime() * SPEED_VALUES[speed] + hueShift,
      BRIGHTNESS_VALUES[brightness],
      SATURATION_VALUES[saturation] * 2,
    );
  }

  // if (getLedStatus(LED_STATUS_CAPS_LOCK)) {
  //   setRgb(31, 128, 128, 128);
  // }
}

func setUnderglow(r, g, b) {
  r = r * brightness >> 3;
  g = g * brightness >> 3;
  b = b * brightness >> 3;
  for(var i = 42; i < 54; i = i + 1) {
    setRgb(i, r, g, b);
  }
}

func updateUnderglowRgb() {
  if (HAS_U2F && isWaitingForUserPresence()) {
    setUnderglow(0, 0, 0);
    return;
  }
  if (HAS_BLE && isBleAdvertising()) {
    setUnderglow(0, 0, 0);
    return;
  }

  if (layer & STENO_MASK) {
    setUnderglow(192, 192, 192);
  } else {
    setUnderglow(159, 96, 192);
  }
}

func updateScreenContrast() {
  if (!HAS_DISPLAY) return;

  var contrast = 16 + 30 * brightness;
  setScreenContrast(0, contrast);
  setScreenContrast(1, contrast);
}

const ICON_POSITIONS = [[
  08 00 00 00 00 00 00 00
  00 00 10 00 00 00 00 00
  00 00 10 00 08 12 00 00
  00 00 10 00 00 12 10 12
]];

func drawDisplay0(layerImage) {
  if (!HAS_DISPLAY) return;
  isShowingScreenSaver = 0;

  setAutoDraw(0, AUTO_DRAW_NONE);
  setAutoDraw(1, AUTO_DRAW_WPM);

  clearDisplay(0);
  drawImage(0, (DISPLAY_WIDTH - layerImage[0]) >> 1, DISPLAY_HEIGHT/2 - 48, layerImage);

  var iconCount = (isScanCodePressed(SC_L_SHIFT) || isScanCodePressed(SC_R_SHIFT))
    + (isScanCodePressed(SC_L_CTRL) || isScanCodePressed(SC_R_CTRL))
    + (isScanCodePressed(SC_L_ALT) || isScanCodePressed(SC_R_ALT))
    + (isScanCodePressed(SC_L_META) || isScanCodePressed(SC_R_META));
  var positions = ICON_POSITIONS + 8 * (iconCount - 1);
  var xOffset = DISPLAY_WIDTH/2 - 16;
  var yOffset = DISPLAY_HEIGHT/2;

  if (isScanCodePressed(SC_L_SHIFT) || isScanCodePressed(SC_R_SHIFT)) {
    drawImage(0, xOffset+positions[0], yOffset+positions[1], SHIFT_IMAGE);
    positions = positions + 2;
  }
  if (isScanCodePressed(SC_L_CTRL) || isScanCodePressed(SC_R_CTRL)) {
    drawImage(0, xOffset+positions[0], yOffset+positions[1], CONTROL_IMAGE);
    positions = positions + 2;
  }
  if (isScanCodePressed(SC_L_ALT) || isScanCodePressed(SC_R_ALT)) {
    drawImage(0, xOffset+positions[0], yOffset+positions[1], ALT_IMAGE);
    positions = positions + 2;
  }
  if (isScanCodePressed(SC_L_META) || isScanCodePressed(SC_R_META)) {
    drawImage(0, xOffset+positions[0], yOffset+positions[1], COMMAND_IMAGE);
  }

  if (getLedStatus(LED_STATUS_CAPS_LOCK)) {
    drawImage(0, DISPLAY_WIDTH/2 - 8, DISPLAY_HEIGHT/2 + 48, CAPS_LOCK_IMAGE);
  } else if (wordCaps) {
    drawImage(0, DISPLAY_WIDTH/2 - 8, DISPLAY_HEIGHT/2 + 48, SHIFT_IMAGE);
  }
}


const BLE_ICONS = [[
  // Laptop
  10 10 fc 67 fe 6f 06 6c 06 6c 06 6c 06 6c 06 6c
  06 6c 06 6c 06 6c 06 6c 06 6c 06 6c 06 6c fe 6f
  fc 67

  // Desktop
  10 10 fe 07 ff 0f 03 0e 03 0e 03 8e 03 8e 03 fe
  03 fe 03 fe 03 fe 03 8e 03 8e 03 0e 03 0e ff 0f
  fe 07

  // Phone
  10 10 00 00 00 00 fe 7f ff ff 03 c0 03 c0 07 c0
  07 c0 07 c0 07 c0 03 c0 03 c0 ff ff fe 7f 00 00
  00 00

  // Tablet
  10 10 00 00 00 00 fe 7f ff ff 07 f0 07 f0 07 f0
  07 90 07 90 07 f0 07 f0 07 f0 ff ff fe 7f 00 00
  00 00
]];

const SLEEPING_ICON = [[
  20 10 00 00 00 00 10 04 10 06 10 05 90 04 50 04
  30 04 10 04 00 00 10 04 10 06 10 05 90 04 50 04
  30 04 10 04 00 00 10 04 10 06 10 05 90 04 50 04
  30 04 10 04 00 00 00 04 00 00 00 04 00 00 00 04
  00 00
]];

const CONNECTED_ICON = [[
  10 10 30 00 38 00 9c 01 cc 01 ce 00 66 0c 66 0e
  66 66 66 66 66 0e 66 0c ce 00 cc 01 9c 01 38 00
  30 00
]];

const DISCONNECTED_ICON = [[
  10 10 30 00 38 00 9c 01 cc 01 ce 70 66 7c 06 1f
  c6 47 f0 61 7c 0c 1f 0c c7 00 c0 01 9c 01 38 00
  30 00
]];

const UNPAIRED_ICON = [[
  10 10 00 00 00 00 80 01 80 01 80 01 80 01 80 01
  80 01 80 01 80 01 80 01 80 01 80 01 80 01 00 00
  00 00
]];

func drawBleSummary() {
  if (!HAS_DISPLAY) return;

  isBleSummaryActive = 1;

  setAutoDraw(0, AUTO_DRAW_NONE);
  setAutoDraw(1, AUTO_DRAW_WPM);

  clearDisplay(0);
  drawImage(0, (DISPLAY_WIDTH - SETTINGS_IMAGE[0]) >> 1, DISPLAY_HEIGHT/2 - 48, SETTINGS_IMAGE);

  const yOffset = DISPLAY_HEIGHT/2 + (DISPLAY_HEIGHT/2 - 76) / 2;

  for (var i = 0; i < 4; i = i + 1) {
    var y = i * 19 + yOffset;
    drawText(0, 11, y + 12, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "1\02\03\04\0" + i*2);

    drawImage(0, 20, y, BLE_ICONS + i * 0x22);

    if (isBleProfileSleeping(i)) {
      drawImage(0, 40, y+2, SLEEPING_ICON);
    } else if (isBleProfileConnected(i)) {
      drawImage(0, 44, y, CONNECTED_ICON);
    } else if (isBleProfilePaired(i)) {
      drawImage(0, 44, y, DISCONNECTED_ICON);
    } else {
      drawImage(0, 44, y, UNPAIRED_ICON);
    }
  }

  var activeY = yOffset + getBleProfile() * 19;
  drawLine(0, 2, activeY - 2, DISPLAY_WIDTH-2, activeY - 2);
  drawLine(0, 2, activeY - 2, 2, activeY + 17);
  drawLine(0, 2, activeY + 17, DISPLAY_WIDTH-2, activeY + 17);
  drawLine(0, DISPLAY_WIDTH-2, activeY - 2, DISPLAY_WIDTH-2, activeY + 17);
}

func updateDisplay0() {
  if (!HAS_DISPLAY) return;

  if (isSettingsLayer()) {
    isBleSummaryActive = 0;
    drawDisplay0(SETTINGS_IMAGE);
  } else if (layer & NUMPAD_MASK) {
    drawDisplay0(NUMPAD_IMAGE);
  } else if (layer & NAV_MASK) {
    drawDisplay0(NAVIGATION_IMAGE);
  } else if (layer & FUNCTION_MASK) {
    drawDisplay0(FUNCTION_IMAGE);
  } else if (layer & SYMBOL_MASK) {
    drawDisplay0(SYMBOL_IMAGE);
  } else if (layer == STENO_MASK) {
    if (stenoDisplay == STENO_DISPLAY_STROKES_WPM) {
      setAutoDraw(0, AUTO_DRAW_STROKES);
      setAutoDraw(1, AUTO_DRAW_WPM);
    } else if (stenoDisplay == STENO_DISPLAY_PAPER_TAPE) {
      setAutoDraw(0, AUTO_DRAW_PAPER_TAPE);
      setAutoDraw(1, AUTO_DRAW_PAPER_TAPE);
    } else {
      drawDisplay0(STENO_IMAGE);

      var mode = getParameter("steno_mode");
      if (mode == "gemini")  {
        if (DISPLAY_WIDTH < 64) {
          drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT - 48, GEMINI_IMAGE);
        } else {
          drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Gemini");
        }
      } else if(mode == "tx_bolt") {
        drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "TX Bolt");
      } else if(mode == "procat") {
        drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "ProCAT");
      } else if(mode == "plover_hid") {
        if (DISPLAY_WIDTH < 64) {
          drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT - 48, PLOVER_HID_IMAGE);
        } else {
          drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Plover HID");
        }
      }
    }
  } else {
    drawDisplay0(QWERTY_IMAGE);

    if (alphabeticLayout == ALPHABETIC_LAYOUT_QWERTY) {
      // drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT/2 - 12, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "QWERTY");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_DVORAK) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT/2 - 12, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Dvorak");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_COLEMAK) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT/2 - 12, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Colemak");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_WORKMAN) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT/2 - 12, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Workman");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_COLEMAK_DH) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT/2 - 12, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "ColemakDH");
    }
  }
}

var lastEvent;
func sendEventUnique(event) {
  if (event == lastEvent) {
    return;
  }
  lastEvent = event;
  sendEvent(event);
}

func sendLayerEvent() {
  if (isSettingsLayer()) {
    // sendEventUnique("layer: settings");
  } else if (layer & NUMPAD_MASK) {
    // sendEventUnique("layer: numpad");
  } else if (layer & NAV_MASK) {
    // sendEventUnique("layer: navigation");
  } else if (layer & FUNCTION_MASK) {
    // sendEventUnique("layer: function");
  } else if (layer & SYMBOL_MASK) {
    // sendEventUnique("layer: symbol");
  } else if (layer & STENO_MASK) {
    // var mode = getParameter("steno_mode");
    // if (mode == "gemini")  {
    //   sendEventUnique("layer: steno_gemini");
    // } else if(mode == "plover_hid") {
    //   sendEventUnique("layer: steno_plover_hid");
    // } else {
    //   sendEventUnique("layer: steno");
    // }
    sendEventUnique("layer: steno");
  } else {
    sendEventUnique("layer: qwerty");
  }
}

func drawBar(barValue) {
  if (!HAS_DISPLAY) return;

  drawImage(0, DISPLAY_WIDTH/2 + 4, DISPLAY_HEIGHT/2, BAR_IMAGES + barValue * 66);
}

var bleTransmitPower = 3;
const POWER_TO_BAR_LENGTH = [[ 00 01 02 04 06 08]];
func updateBleTransmitPower(power) {
  if (!HAS_BLE) return;
  if (!ENABLE_BLE_TRANSMIT_POWER_CONTROLS) return;

  bleTransmitPower = power;

  var text;
  if (power == 0) {
    console("set_ble_transmit_power -12");
    text = "-12 dB";
  } else if (power == 1) {
    console("set_ble_transmit_power -8");
    text = "-8 dB";
  } else if (power == 2) {
    console("set_ble_transmit_power -4");
    text = "-4 dB";
  } else if (power == 3) {
    console("set_ble_transmit_power 0");
    text = "0 dB";
  } else if (power == 4) {
    console("set_ble_transmit_power 4");
    text = "4 dB";
  } else if (power == 5) {
    console("set_ble_transmit_power 8");
    text = "8 dB";
  }

  if (!HAS_DISPLAY) return;

  updateDisplay0();
  drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT/2 + 24, CONNECTED_ICON);
  drawBar(POWER_TO_BAR_LENGTH[power]);
  drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, text);
}

var bleSplitTransmitPower = 3;
func updateBleSplitTransmitPower(power) {
  if (!HAS_BLE) return;
  if (!ENABLE_BLE_TRANSMIT_POWER_CONTROLS) return;

  bleSplitTransmitPower = power;

  var text;
  if (power == 0) {
    console("set_ble_split_transmit_power -12");
    console("pair set_ble_split_transmit_power -12");
    text = "-12 dB";
  } else if (power == 1) {
    console("set_ble_split_transmit_power -8");
    console("pair set_ble_split_transmit_power -8");
    text = "-8 dB";
  } else if (power == 2) {
    console("set_ble_split_transmit_power -4");
    console("pair set_ble_split_transmit_power -4");
    text = "-4 dB";
  } else if (power == 3) {
    console("set_ble_split_transmit_power 0");
    console("pair set_ble_split_transmit_power 0");
    text = "0 dB";
  } else if (power == 4) {
    console("set_ble_split_transmit_power 4");
    console("pair set_ble_split_transmit_power 4");
    text = "4 dB";
  } else if (power == 5) {
    console("set_ble_split_transmit_power 8");
    console("pair set_ble_split_transmit_power 8");
    text = "8 dB";
  }

  if (!HAS_DISPLAY) return;

  updateDisplay0();
  drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT/2 + 24, PAIR_CONNECTED_STATUS_IMAGES + PAIR_CONNECTED_STATUS_IMAGE_OFFSETS[PAIR_CONNECTION_BLE]);
  drawBar(POWER_TO_BAR_LENGTH[power]);
  drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, text);
}

func drawBrightness() {
  if (!HAS_DISPLAY) return;

  updateDisplay0();
  drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT/2 + 24, BRIGHTNESS_IMAGE);
  drawBar(brightness);
}

func drawSpeed() {
  if (!HAS_DISPLAY) return;

  updateDisplay0();
  drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT/2 + 24, SPEED_IMAGE);
  drawBar(speed);
}

func drawHueSpread() {
  if (!HAS_DISPLAY) return;

  updateDisplay0();
  drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT/2 + 24, HUE_SPREAD_IMAGE);
  drawBar(hueSpread);
}

func drawSaturation() {
  if (!HAS_DISPLAY) return;

  updateDisplay0();
  drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT/2 + 24, CONTRAST_IMAGE);
  drawBar(saturation);
}

func setLayer(value) {
  releaseAll();
  if (HAS_BLE) stopTimer(TIMER_ID_PAIRING_HOLD);
  stopTimer(TIMER_ID_CAPS_HOLD);
  layer = value;
  sendLayerEvent();
  updateKeyRgb();
  updateUnderglowRgb();
  updateDisplay0();

  setInputHint(value == STENO_MASK ? INPUT_HINT_STENOGRAPHY : INPUT_HINT_KEYBOARD);
}

func isModifierKey(key) var {
  return SC_L_CTRL <= key && key <= SC_R_META;
}

func isWordCapsModifierKey(key) var {
  var v = key | 4;
  return v == SC_R_SHIFT || key == SC_R_ALT;
}

func isWordKey(key) var {
  return SC_A <= key && key <= SC_Z;
}

func isDigitKey(key) var {
  return SC_1 <= key && key <= SC_0;
}

func press(key) {
  if (key == SC_NONE || key == SK_NONE) {
    return;
  }

  if (isInPressAll() && !isModifierKey(key)) {
    return;
  }

  // When rapidly pressing a pair of keys, where the first includes shift,
  // and the second one doesn't, the second can easily end up with the shift
  // version unintentionally. This is especially evident with symbols, so
  // release it here if the last key has shift, but the new key doesn't.
  if (isScanCodePressed(lastPressKey & 0xff)) {
    if ((lastPressKey & KEY_SHIFT) && (key & KEY_SHIFT) == 0) {
      // Makes it possible to tap "+=" quickly.
      releaseScanCode(lastPressKey & 0xff);
      releaseScanCode(SC_L_SHIFT);
    }
  }

  if (key & KEY_STENO) {
    pressStenoKey(key & 0xff);
  } else {
    var display0NeedsUpdate = 0;
    if (wordCaps) {
      if (isWordKey(key) && (key & KEY_SHIFT) == 0) {
        key = key | KEY_SHIFT;
      } else if (!isWordCapsModifierKey(key)
          && key != (SC_MINUS | KEY_SHIFT)
          && key != SC_BACKSPACE
          && !isDigitKey(key)) {
        wordCaps = 0;
        display0NeedsUpdate = 1;
      }
    }
    if (key & KEY_SHIFT) {
      pressScanCode(SC_L_SHIFT);
    }
    var scanCode = key & 0xff;
    pressScanCode(scanCode);

    if (display0NeedsUpdate || isModifierKey(scanCode)) {
      updateDisplay0();
    }
  }

  lastPressLayer = layer;
  lastPressKey = key;
  pressCount = pressCount + 1;
}

func release(key) {
  if (key == SC_NONE || key == SK_NONE) {
    return;
  }

  if (key & KEY_STENO) {
    releaseStenoKey(key & 0xff);
  } else {
    if (wordCaps && key == (lastPressKey & 0xff)) {
      if (isWordKey(key)) {
        key = key | KEY_SHIFT;
      }
    }
    if (key & KEY_SHIFT) {
      releaseScanCode(SC_L_SHIFT);
    }

    var scanCode = key & 0xff;
    releaseScanCode(scanCode);

    if (isModifierKey(scanCode)) {
      updateDisplay0();
    }
  }
}

func tap(key) {
  press(key);
  release(key);
}

func isSettingsLayer() var {
  return (layer & (SYMBOL_MASK | FUNCTION_MASK)) == (SYMBOL_MASK | FUNCTION_MASK);
}

func updateButtonColor(buttonIndex) {
  if ((layer & STENO_MASK) == 0) {
    keyColorData[buttonIndex] = rand() & 0xffff;

    // If there's no update of keys in the tick loop, update it now.
    if (!isTimerActive(TIMER_ID_RGB_UPDATE)) {
      updateKeyRgb();
    }
  }
}

func updateAllButtonColors() {
  for (var i = 0; i < 42; i = i + 1) {
    keyColorData[i] = (rand() & 0xffff) | 0x20000000;
  }
}

func fuzzyLayerTimeout() {
  press(deferredLayerKey);
  deferredLayerKey = 0;
  deferredAlphabeticKey = 0;
}

func handlePress(buttonIndex, stenoKey, symbolsKey, functionKey, navKey, numPadKey) {
  if (!isInPressAll()) {
    updateButtonColor(buttonIndex);
  }
  updateScreenSaverTimer();

  var alphabeticKey = buttonScanCodes[ALPHABETIC_LAYOUT_COUNT * buttonIndex + alphabeticLayout];
  if (isSettingsLayer()) {
    return;
  } else if (layer & NUMPAD_MASK) {
    press(numPadKey);
  } else if (layer & NAV_MASK) {
    if (deferredLayerKey) {
      press(deferredLayerKey);

      deferredLayerKey = 0;
      deferredAlphabeticKey = 0;
      stopTimer(TIMER_ID_FUZZY_LAYER);

      press(navKey);
    } else if (getTime() - navLayerPressTimestamp < LAYER_PRESS_TO_KEY_PRESS_THRESHOLD) {
      deferredLayerKey = navKey;
      deferredAlphabeticKey = alphabeticKey;
      startTimer(TIMER_ID_FUZZY_LAYER, KEY_PRESS_TO_LAYER_RELEASE_THRESHOLD, 0, @fuzzyLayerTimeout);
    } else {
      press(navKey);
    }
  } else if (layer & FUNCTION_MASK) {
    if (deferredLayerKey) {
      press(deferredLayerKey);

      deferredLayerKey = 0;
      deferredAlphabeticKey = 0;
      stopTimer(TIMER_ID_FUZZY_LAYER);

      press(functionKey);
    } else if (getTime() - functionLayerPressTimestamp < LAYER_PRESS_TO_KEY_PRESS_THRESHOLD) {
      deferredLayerKey = functionKey;
      deferredAlphabeticKey = alphabeticKey;
      startTimer(TIMER_ID_FUZZY_LAYER, KEY_PRESS_TO_LAYER_RELEASE_THRESHOLD, 0, @fuzzyLayerTimeout);
    } else {
      press(functionKey);
    }
  } else if (layer & SYMBOL_MASK) {
    press(symbolsKey);
  } else if (layer & TEMPORARY_QWERTY_MASK) {
    press(alphabeticKey);
  } else if (layer & STENO_MASK) {
    press(stenoKey);
  } else {
    press(alphabeticKey);
  }
}
func handleRelease(buttonIndex, stenoKey, symbolsKey, functionKey, navKey, numPadKey) {
  updateScreenSaverTimer();
  if (isSettingsLayer()) {
    return;
  } else if (layer & NUMPAD_MASK) {
    release(numPadKey);
  } else if (layer & NAV_MASK) {
    if (deferredLayerKey) {
      if (isButtonPressed(NAV_BUTTON)) {
        press(deferredLayerKey);
        deferredLayerKey = 0;
        deferredAlphabeticKey = 0;
      }
    }

    release(navKey);
  } else if (layer & FUNCTION_MASK) {
    if (deferredLayerKey) {
      if (isButtonPressed(FUNCTION_BUTTON)) {
        press(deferredLayerKey);
        deferredLayerKey = 0;
        deferredAlphabeticKey = 0;
      }
    }

    release(functionKey);
  } else if (layer & SYMBOL_MASK) {
    release(symbolsKey);
  } else if (layer & TEMPORARY_QWERTY_MASK) {
    release(buttonScanCodes[ALPHABETIC_LAYOUT_COUNT * buttonIndex + alphabeticLayout]);
  } else if (layer & STENO_MASK) {
    release(stenoKey);
  } else {
    release(buttonScanCodes[ALPHABETIC_LAYOUT_COUNT * buttonIndex + alphabeticLayout]);
  }
}

func onPairingHoldTimer() {
  startBlePairing();
}

func onPress0() {
  if (layer & STENO_MASK) {
      setInputHint(INPUT_HINT_KEYBOARD);
  }
  handlePress(0, SC_TAB, SC_GRAVE, SC_NONE, SC_NONE, SC_NONE);

  if (isSettingsLayer()) {
    setPreferredConnection(CONNECTION_USB, CONNECTION_USB2, CONNECTION_BLE);
    if (HAS_DISPLAY) {
      updateDisplay0();
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "USB L");
    }
  }
}
func onRelease0() {
  handleRelease(0, SC_TAB, SC_GRAVE, SC_NONE, SC_NONE, SC_NONE);

  if (layer & STENO_MASK) {
      setInputHint(INPUT_HINT_STENOGRAPHY);
  }
}

func onPress1() {
  handlePress(1, SK_S1 | KEY_STENO, SC_1, SC_F9, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    setPreferredConnection(CONNECTION_BLE, CONNECTION_USB, CONNECTION_USB2);
    setBleProfile(0);
    if (HAS_DISPLAY) {
      drawBleSummary();
    }
    startTimer(TIMER_ID_PAIRING_HOLD, 2000, 0, @onPairingHoldTimer);
  }
}
func onRelease1() {
  handleRelease(1, SK_S1 | KEY_STENO, SC_1, SC_F9, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    stopTimer(TIMER_ID_PAIRING_HOLD);
  }
}

func onPress2() {
  handlePress(2, SK_TL | KEY_STENO, SC_2, SC_F10, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    setPreferredConnection(CONNECTION_BLE, CONNECTION_USB, CONNECTION_USB2);
    setBleProfile(1);
    if (HAS_DISPLAY) {
      drawBleSummary();
    }
    startTimer(TIMER_ID_PAIRING_HOLD, 2000, 0, @onPairingHoldTimer);
  }
}
func onRelease2() {
  handleRelease(2, SK_TL | KEY_STENO, SC_2, SC_F10, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    stopTimer(TIMER_ID_PAIRING_HOLD);
  }
}

func onPress3() {
  handlePress(3, SK_PL | KEY_STENO, SC_3, SC_F11, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    setPreferredConnection(CONNECTION_BLE, CONNECTION_USB, CONNECTION_USB2);
    setBleProfile(2);
    if (HAS_DISPLAY) {
      drawBleSummary();
    }
    startTimer(TIMER_ID_PAIRING_HOLD, 2000, 0, @onPairingHoldTimer);
  }
}
func onRelease3() {
  handleRelease(3, SK_PL | KEY_STENO, SC_3, SC_F11, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    stopTimer(TIMER_ID_PAIRING_HOLD);
  }
}

func onPress4() {
  handlePress(4, SK_HL | KEY_STENO, SC_4, SC_F12, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    setPreferredConnection(CONNECTION_BLE, CONNECTION_USB, CONNECTION_USB2);
    setBleProfile(3);
    if (HAS_DISPLAY) {
      drawBleSummary();
    }
    startTimer(TIMER_ID_PAIRING_HOLD, 2000, 0, @onPairingHoldTimer);
  }
}
func onRelease4() {
  handleRelease(4, SK_HL | KEY_STENO, SC_4, SC_F12, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    stopTimer(TIMER_ID_PAIRING_HOLD);
  }
}

func onPress5() {
  handlePress(5, SK_STAR1 | KEY_STENO, SC_5, SC_NONE, SC_CONSUMER_BRIGHTNESS_UP, SC_NONE);

  if (isSettingsLayer()) {
    setPreferredConnection(CONNECTION_USB2, CONNECTION_USB, CONNECTION_BLE);
    if (HAS_DISPLAY) {
      updateDisplay0();
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "USB R");
    }
  }
}
func onRelease5() { handleRelease(5, SK_STAR1 | KEY_STENO, SC_5, SC_NONE, SC_CONSUMER_BRIGHTNESS_UP, SC_NONE); }

func onPress6() {
  handlePress(6, SK_STAR2 | KEY_STENO, SC_6, SC_NONE, SC_CONSUMER_VOLUME_UP, SC_NONE);

  if (isSettingsLayer()) {
    if (speed < 8) {
      // Adjust hue to avoid glitches.
      hueShift = hueShift + animationTime() * (SPEED_VALUES[speed] - SPEED_VALUES[speed + 1]);

      speed = speed + 1;
    }
    drawSpeed();
  }
}
func onRelease6() { handleRelease(6, SK_STAR2 | KEY_STENO, SC_6, SC_NONE, SC_CONSUMER_VOLUME_UP, SC_NONE); }

func onPress7() { handlePress(7, SK_FR | KEY_STENO, SC_7, SC_NONE, SC_BACKSPACE, SC_KP_7); }
func onRelease7() { handleRelease(7, SK_FR | KEY_STENO, SC_7, SC_NONE, SC_BACKSPACE, SC_KP_7); }

func onPress8() {
  handlePress(8, SK_PR | KEY_STENO, SC_8, SC_NONE, SC_UP, SC_KP_8);

  if (isSettingsLayer()) {
    if (brightness < 8) {
      brightness = brightness + 1;
      updateBoardPower();
      updateScreenContrast();
    }
    drawBrightness();
  }
}
func onRelease8() { handleRelease(8, SK_PR | KEY_STENO, SC_8, SC_NONE, SC_UP, SC_KP_8); }

func onPress9() {
  handlePress(9, SK_LR | KEY_STENO, SC_9, SC_NONE, SC_DELETE, SC_KP_9);

  if (isSettingsLayer()) {
    if (saturation < 8) {
      saturation = saturation + 1;
      updateKeyRgb();
    }
    drawSaturation();
  }
}
func onRelease9() { handleRelease(9, SK_LR | KEY_STENO, SC_9, SC_NONE, SC_DELETE, SC_KP_9); }

func onPress10() {
  handlePress(10, SK_TR | KEY_STENO, SC_0, SC_NONE, SC_PAGE_UP, SC_KP_ASTERISK);

  if (isSettingsLayer()) {
    hueShift = hueShift - 0x800;
  }
}
func onRelease10() { handleRelease(10, SK_TR | KEY_STENO, SC_0, SC_NONE, SC_PAGE_UP, SC_KP_ASTERISK); }

func onPress11() {
  handlePress(11, SK_DR | KEY_STENO, SC_EQUAL, SC_NONE, SC_HOME, SC_BACKSPACE);

  if (isSettingsLayer()) {
    if (hueSpread < 8) {
      hueSpread = hueSpread + 1;
    }
    drawHueSpread();
  }
}
func onRelease11() { handleRelease(11, SK_DR | KEY_STENO, SC_EQUAL, SC_NONE, SC_HOME, SC_BACKSPACE); }

// 2nd row

var timer12;
var pressCount12;
var wasSteno12;
func onPress12() {
  if (!isInPressAll()) {
    wasSteno12 = layer == STENO_MASK;
    if (wasSteno12) {
      setLayer(layer | TEMPORARY_QWERTY_MASK);
    }
  }
  handlePress(12, SC_NONE, SC_GRAVE | KEY_SHIFT, SC_NONE, SC_NONE, SC_NONE);
  update24();

  if (!isInPressAll()) {
    timer12 = getTime();
    pressCount12 = pressCount;
  }

  if (ENABLE_BLE_TRANSMIT_POWER_CONTROLS && isSettingsLayer()) {
    updateBleTransmitPower(bleTransmitPower < 5 ? bleTransmitPower + 1 : 5);
  }
}
func onRelease12() {
  if (wasSteno12) {
    setLayer(STENO_MASK);
  } else {
    handleRelease(12, SC_NONE, SC_GRAVE | KEY_SHIFT, SC_NONE, SC_NONE, SC_NONE);
    update24();
  }

  if ((layer == 0 || wasSteno12)
      && pressCount12 == pressCount
      && getTime() - timer12 < TAP_THRESHOLD) {
    tap(SC_ESC);
    if (HAS_U2F) {
      replyUserPresence(0);
    }
  }
}

func onPress13() {
  handlePress(13, SK_S2 | KEY_STENO, SC_1 | KEY_SHIFT, SC_F5, SC_L_META, SC_L_META);

  if (ENABLE_BLE_TRANSMIT_POWER_CONTROLS && isSettingsLayer()) {
    updateBleSplitTransmitPower(bleSplitTransmitPower < 5 ? bleSplitTransmitPower + 1 : 5);
  }
}

func onRelease13() { handleRelease(13, SK_S2 | KEY_STENO, SC_1 | KEY_SHIFT, SC_F5, SC_L_META, SC_L_META); }

func onPress14() {
  handlePress(14, SK_KL | KEY_STENO, SC_2 | KEY_SHIFT, SC_F6, SC_L_ALT, SC_L_ALT);

  if (isSettingsLayer()) {
    console("set_steno_mode embedded");
    if (HAS_DISPLAY) {
      updateDisplay0();
      if (DISPLAY_WIDTH < 64) {
        drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT - 48, EMBEDDED_IMAGE);
      } else {
        drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Javelin");
      }
    }
  }
}
func onRelease14() { handleRelease(14, SK_KL | KEY_STENO, SC_2 | KEY_SHIFT, SC_F6, SC_L_ALT, SC_L_ALT); }

func onPress15() {
  handlePress(15, SK_WL | KEY_STENO, SC_3 | KEY_SHIFT, SC_F7, SC_L_CTRL, SC_L_CTRL);

  if (isSettingsLayer()) {
    console("set_steno_mode gemini");
    if (HAS_DISPLAY) {
      updateDisplay0();
      if (DISPLAY_WIDTH < 64) {
        drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT - 48, GEMINI_IMAGE);
      } else {
        drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Gemini");
      }
    }
  }
}
func onRelease15() { handleRelease(15, SK_WL | KEY_STENO, SC_3 | KEY_SHIFT, SC_F7, SC_L_CTRL, SC_L_CTRL); }

func onPress16() {
  handlePress(16, SK_RL | KEY_STENO, SC_4 | KEY_SHIFT, SC_F8, SC_L_SHIFT, SC_L_SHIFT);

  if (isSettingsLayer()) {
    console("set_steno_mode tx_bolt");
    if (HAS_DISPLAY) {
      updateDisplay0();
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "TX Bolt");
    }
  }
}
func onRelease16() { handleRelease(16, SK_RL | KEY_STENO, SC_4 | KEY_SHIFT, SC_F8, SC_L_SHIFT, SC_L_SHIFT); }

func onPress17() {
  handlePress(17, SK_STAR3 | KEY_STENO, SC_5 | KEY_SHIFT, SC_NONE, SC_CONSUMER_BRIGHTNESS_DOWN, SC_NONE);

  if (isSettingsLayer()) {
    console("set_steno_mode plover_hid");
    if (HAS_DISPLAY) {
      updateDisplay0();
      if (DISPLAY_WIDTH < 64) {
        drawImage(0, DISPLAY_WIDTH/2 - 16, DISPLAY_HEIGHT - 48, PLOVER_HID_IMAGE);
      } else {
        drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT - 48 + 10, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Plover HID");
      }
    }
  }
}
func onRelease17() { handleRelease(17, SK_STAR3 | KEY_STENO, SC_5 | KEY_SHIFT, SC_NONE, SC_CONSUMER_BRIGHTNESS_DOWN, SC_NONE); }

func onPress18() {
  handlePress(18, SK_STAR4 | KEY_STENO, SC_6 | KEY_SHIFT, SC_NONE, SC_CONSUMER_VOLUME_DOWN, SC_NONE);

  if (isSettingsLayer()) {
    if (speed > 0) {
      // Adjust hue to avoid glitches.
      hueShift = hueShift + animationTime() * (SPEED_VALUES[speed] - SPEED_VALUES[speed - 1]);

      speed = speed - 1;
    }
    drawSpeed();
  }
}
func onRelease18() { handleRelease(18, SK_STAR4 | KEY_STENO, SC_6 | KEY_SHIFT, SC_NONE, SC_CONSUMER_VOLUME_DOWN, SC_NONE); }

func onPress19() { handlePress(19, SK_RR | KEY_STENO, SC_7 | KEY_SHIFT, SC_L_SHIFT, SC_LEFT, SC_KP_4); }
func onRelease19() { handleRelease(19, SK_RR | KEY_STENO, SC_7 | KEY_SHIFT, SC_L_SHIFT, SC_LEFT, SC_KP_4); }

func onPress20() {
  handlePress(20, SK_BR | KEY_STENO, SC_8 | KEY_SHIFT, SC_L_CTRL, SC_DOWN, SC_KP_5);

  if (isSettingsLayer()) {
    if (brightness > 0) {
      brightness = brightness - 1;
      updateBoardPower();
      updateScreenContrast();
    }
    drawBrightness();
  }
}
func onRelease20() { handleRelease(20, SK_BR | KEY_STENO, SC_8 | KEY_SHIFT, SC_L_CTRL, SC_DOWN, SC_KP_5); }

func onPress21() {
  handlePress(21, SK_GR | KEY_STENO, SC_9 | KEY_SHIFT, SC_L_ALT, SC_RIGHT, SC_KP_6);

  if (isSettingsLayer()) {
    if (saturation > 0) {
      saturation = saturation - 1;
      updateKeyRgb();
    }
    drawSaturation();
  }
}
func onRelease21() { handleRelease(21, SK_GR | KEY_STENO, SC_9 | KEY_SHIFT, SC_L_ALT, SC_RIGHT, SC_KP_6); }

func onPress22() {
  handlePress(22, SK_SR | KEY_STENO, SC_0 | KEY_SHIFT, SC_L_META, SC_PAGE_DOWN, SC_KP_MINUS);

  if (isSettingsLayer()) {
    hueShift = hueShift + 0x800;
  }
}
func onRelease22() { handleRelease(22, SK_SR | KEY_STENO, SC_0 | KEY_SHIFT, SC_L_META, SC_PAGE_DOWN, SC_KP_MINUS); }

func onPress23() {
  handlePress(23, SK_ZR | KEY_STENO, SC_EQUAL | KEY_SHIFT, SC_NONE, SC_END, SC_KP_PLUS);

  if (isSettingsLayer()) {
    if (hueSpread > 0) {
      hueSpread = hueSpread - 1;
    }
    drawHueSpread();
  }
}
func onRelease23() { handleRelease(23, SK_ZR | KEY_STENO, SC_EQUAL | KEY_SHIFT, SC_NONE, SC_END, SC_KP_PLUS); }

// 3rd row

var timer24;
var wasSteno24;
var pressCount24;
var wasShiftPressed24;
func update24() {
  if (isButtonPressed(24)
        && (isButtonPressed(12 /*CTRL*/) || isButtonPressed(36 /*META*/))
        && (layer == ALPHABETIC_LAYER || (layer & TEMPORARY_QWERTY_MASK))) {
    press(SC_L_SHIFT);
    wasShiftPressed24 = 1;
  } else if (wasShiftPressed24) {
    release(SC_L_SHIFT);
    wasShiftPressed24 = 0;
  }
}
func onPress24() {
  handlePress(24, SC_NONE, SC_SLASH | KEY_SHIFT, SC_NONE, SC_NONE, SC_NONE);

  if (isInPressAll()) {
    update24();
    return;
  }

  wasSteno24 = layer == STENO_MASK;
  wasShiftPressed24 = (layer == ALPHABETIC_LAYER || (layer & TEMPORARY_QWERTY_MASK));

  if (ENABLE_BLE_TRANSMIT_POWER_CONTROLS && isSettingsLayer()) {
    updateBleTransmitPower(bleTransmitPower > 0 ? bleTransmitPower - 1 : 0);
    return;
  }

  if (wasSteno24) {
    setLayer(layer ^ STENO_MASK);
    pressCount24 = pressCount;
    pressAll();
  } else {
    if (wasShiftPressed24) {
      press(SC_L_SHIFT);
    }
    pressCount24 = pressCount;
  }
  timer24 = getTime();
}
func onRelease24() {
  handleRelease(24, SC_NONE, SC_SLASH | KEY_SHIFT, SC_NONE, SC_NONE, SC_NONE);

  if (wasShiftPressed24) {
    release(SC_L_SHIFT);
  }

  if (wasSteno24) {
    // If the keypress was in steno mode, and other keys were pressed, or it
    // was a long press, drop immediately back to steno mode, and drop all masks.
    if (pressCount24 != pressCount || layer || getTime() - timer24 >= TAP_THRESHOLD) {
      setLayer(STENO_MASK);
    }
  } else if (layer == 0 && pressCount24 == pressCount
      && getTime() - timer24 < TAP_THRESHOLD
      && checkButtonState("000000000000000000000000000000000000000000")) {
    // A tap of the key turns on steno mode.
    // Automatically turn off word caps when entering steno mode.
    wordCaps = 0;

    setLayer(layer | STENO_MASK);
  }
  updateUnderglowRgb();
}

func onPress25() {
  handlePress(25, SC_NONE, SC_BACKSLASH, SC_F1, SC_NONE, SC_NONE);

  if (ENABLE_BLE_TRANSMIT_POWER_CONTROLS && isSettingsLayer()) {
    updateBleSplitTransmitPower(bleSplitTransmitPower > 0 ? bleSplitTransmitPower - 1 : 0);
  }
}
func onRelease25() { handleRelease(25, SC_NONE, SC_BACKSLASH, SC_F1, SC_NONE, SC_NONE); }

func onPress26() {
  handlePress(26, SC_NONE, SC_BACKSLASH | KEY_SHIFT, SC_F2, SC_NONE, SC_NONE);

  if (HAS_DISPLAY && isSettingsLayer()) {
    stenoDisplay = STENO_DISPLAY_WPM;
    updateDisplay0();
    drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "WPM");
  }
}
func onRelease26() { handleRelease(26, SC_NONE, SC_BACKSLASH | KEY_SHIFT, SC_F2, SC_NONE, SC_NONE); }

func onPress27() {
  handlePress(27, SC_NONE, SC_MINUS, SC_F3, SC_NONE, SC_NONE);

  if (HAS_DISPLAY && isSettingsLayer()) {
    stenoDisplay = STENO_DISPLAY_PAPER_TAPE;
    updateDisplay0();
    drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Tape");
  }
}
func onRelease27() { handleRelease(27, SC_NONE, SC_MINUS, SC_F3, SC_NONE, SC_NONE); }

func onPress28() {
  handlePress(28, SC_NONE, SC_L_BRACKET, SC_F4, SC_NONE, SC_NONE);

  if (HAS_DISPLAY && isSettingsLayer()) {
    stenoDisplay = STENO_DISPLAY_STROKES_WPM;
    updateDisplay0();
    drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Strokes");
  }
}
func onRelease28() { handleRelease(28, SC_NONE, SC_L_BRACKET, SC_F4, SC_NONE, SC_NONE); }

func onPress29() {
  handlePress(29, SC_NONE, SC_L_BRACKET | KEY_SHIFT, SC_NONE, SC_NONE, SC_NONE);

  if (HAS_BLE && isSettingsLayer()) {
    if (isBleProfileConnected(getBleProfile())) {
      disconnectBle();
    } else if (isBleProfilePaired(getBleProfile())) {
      unpairBle();
      drawBleSummary();
    }
  }
}
func onRelease29() { handleRelease(29, SC_NONE, SC_L_BRACKET | KEY_SHIFT, SC_NONE, SC_NONE, SC_NONE); }

func onPress30() { handlePress(30, SC_NONE, SC_R_BRACKET | KEY_SHIFT, SC_NONE, SC_CONSUMER_MUTE, SC_NONE); }
func onRelease30() { handleRelease(30, SC_NONE, SC_R_BRACKET | KEY_SHIFT, SC_NONE, SC_CONSUMER_MUTE, SC_NONE); }

func onPress31() { handlePress(31, SC_NONE, SC_R_BRACKET, SC_NONE, SC_NONE, SC_KP_1); }
func onRelease31() { handleRelease(31, SC_NONE, SC_R_BRACKET, SC_NONE, SC_NONE, SC_KP_1); }

func onPress32() { handlePress(32, SC_NONE, SC_MINUS | KEY_SHIFT, SC_NONE, SC_NONE, SC_KP_2); }
func onRelease32() { handleRelease(32, SC_NONE, SC_MINUS | KEY_SHIFT, SC_NONE, SC_NONE, SC_KP_2); }

func onPress33() { handlePress(33, SC_NONE, SC_DOT, SC_NONE, SC_NONE, SC_KP_3); }
func onRelease33() { handleRelease(33, SC_NONE, SC_DOT, SC_NONE, SC_NONE, SC_KP_3); }

func onPress34() { handlePress(34, SC_NONE, SC_SLASH, SC_NONE, SC_NONE, SC_KP_SLASH); }
func onRelease34() { handleRelease(34, SC_NONE, SC_SLASH, SC_NONE, SC_NONE, SC_KP_SLASH); }

func tapCapsLock() {
  // Tapping caps lock on macOS does not activate it.
  // There needs to be a delay, so a timer is used to trigger the release.
  pressScanCode(SC_CAPS);
  startTimer(TIMER_ID_CAPS_RELEASE, 200, 0, @{
    releaseScanCode(SC_CAPS);
    wordCaps = 0;
  });
}

var timer35;
var releaseTimer35;
var tapCount35;
var pressCount35;
var magicKey35;
func onPress35() {
  // Magic key handling.
  magicKey35 = SC_NONE;
  if (layer & (SYMBOL_MASK | NUMPAD_MASK)) {
    if (lastPressKey == SC_MINUS || lastPressKey == SC_EQUAL) {
      magicKey35 = SC_DOT | KEY_SHIFT;
    } else if (lastPressKey == (SC_9 | KEY_SHIFT) || lastPressKey == SC_BACKSLASH || lastPressKey == (SC_APOSTROPHE | KEY_SHIFT)) {
      magicKey35 = SC_APOSTROPHE | KEY_SHIFT;
    } else if (SC_1 <= lastPressKey && lastPressKey <= SC_0) {
      magicKey35 = SC_COMMA;
    } else if (SC_KP_1 <= lastPressKey && lastPressKey <= SC_KP_0) {
      magicKey35 = SC_COMMA;
    } else if ((lastPressKey | KEY_SHIFT) == (SC_L_BRACKET | KEY_SHIFT)) {
      magicKey35 = SC_ENTER;
    } else if (lastPressKey == SC_COMMA || lastPressKey == SC_DOT || lastPressKey == SC_KP_DOT) {
      magicKey35 = SC_SPACE;
    }
  }

  handlePress(35, SC_NONE, magicKey35, SC_NONE, SC_NONE, magicKey35);

  if ((layer >> 1) == 0) {
    timer35 = getTime();
    pressCount35 = pressCount;
    if (timer35 - releaseTimer35 < RELEASE_TO_TAP_THRESHOLD) {
      tapCount35 = tapCount35 + 1;
      if (tapCount35 == 1) {
        if (wordCaps) {
          wordCaps = 0;
          updateDisplay0();
        } else if (getLedStatus(LED_STATUS_CAPS_LOCK)) {
          tapCapsLock();
        } else if (layer == 0) {
          wordCaps = wordCaps ^ 1;
          updateDisplay0();
          startTimer(TIMER_ID_CAPS_HOLD, TAP_THRESHOLD, 0, @tapCapsLock);
        }
      }
    } else {
      tapCount35 = 0;
    }
  }

  if (isSettingsLayer()) {
    alphabeticLayout = (alphabeticLayout + 1) % ALPHABETIC_LAYOUT_COUNT;
    updateDisplay0();
    if (alphabeticLayout == ALPHABETIC_LAYOUT_QWERTY) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "QWERTY");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_DVORAK) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Dvorak");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_COLEMAK) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Colemak");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_WORKMAN) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "Workman");
    } else if (alphabeticLayout == ALPHABETIC_LAYOUT_COLEMAK_DH) {
      drawText(0, DISPLAY_WIDTH/2, DISPLAY_HEIGHT * 3 / 4, FONT_ID_NORMAL, TEXT_ALIGNMENT_MIDDLE, "ColemakDH");
    }
  }

  if (HAS_U2F && checkButtonState("000000000000000000000000100000000001110010")) {
    replyUserPresence(1);
  }
}
func onRelease35() {
  handleRelease(35, SC_NONE, magicKey35, SC_NONE, SC_NONE, magicKey35);
  stopTimer(TIMER_ID_CAPS_HOLD);

  if ((layer >> 1) == 0 && pressCount35 == pressCount && getTime() - timer35 < TAP_THRESHOLD) {
    releaseTimer35 = getTime();
  }
}

// 4th row

var wasSteno36;
func onPress36() {
  if (!isInPressAll()) {
    wasSteno36 = layer == STENO_MASK;
    if (wasSteno36) {
      setLayer(layer | TEMPORARY_QWERTY_MASK);
    }
  }
  handlePress(36, SC_NONE, SC_L_META, SC_NONE, SC_NONE, SC_NONE);
  update24();
}
func onRelease36() {
  handleRelease(36, SC_NONE, SC_L_META, SC_NONE, SC_NONE, SC_NONE);
  update24();
  if (wasSteno36) {
    setLayer(STENO_MASK);
  }
}

var timer37;
var pressCount37;
func onPress37() {
  handlePress(37, SK_A | KEY_STENO, SC_L_ALT, SC_NONE, SC_NONE, SC_NONE);
  if (!isInPressAll()) {
    timer37 = getTime();
    pressCount37 = pressCount37;

  }
  if ((layer & (NAV_MASK | NUMPAD_MASK))  == NAV_MASK) {
    setLayer(layer | NUMPAD_MASK);
    pressAll();
  }
}
func onRelease37() {
  handleRelease(37, SK_A | KEY_STENO, SC_L_ALT, SC_NONE, SC_NONE, SC_NONE);
  if (!isInPressAll() && layer == 0 && pressCount37 == pressCount && getTime() - timer37 < TAP_THRESHOLD) {
    tap(SC_ENTER);
  }
  if (layer & NUMPAD_MASK) {
    setLayer(layer ^ NUMPAD_MASK);
    pressAll();
  }
}

var timer38;
var pressCount38;
func onPress38() {
  handlePress(38, SK_O | KEY_STENO, SC_L_CTRL, SC_NONE, SC_NONE, SC_NONE);

  if (!isInPressAll()) {
    timer38 = getTime();
  }

  if (layer == 0) {
    setLayer(layer | NAV_MASK);
    if (!isInPressAll()) {
      pressAll();
      navLayerPressTimestamp = getTime();
      pressCount38 = pressCount;
    }
  } else if (layer & TEMPORARY_QWERTY_MASK) {
    press(SC_SPACE);
  }
}
func onRelease38() {
  handleRelease(38, SK_O | KEY_STENO, SC_L_CTRL, SC_NONE, SC_NONE, SC_NONE);
  if (layer & NAV_MASK) {
    var startPressCount = pressCount;

    setLayer(layer & ~(NAV_MASK | NUMPAD_MASK));
    pressAll();

    if (layer == 0 && pressCount38 == startPressCount && getTime() - navLayerPressTimestamp < TAP_THRESHOLD) {
      tap(SC_SPACE);
    }
    tap(deferredAlphabeticKey);
    deferredLayerKey = 0;
    deferredAlphabeticKey = 0;
  } else if (layer & SYMBOL_MASK) {
    if (getTime() - timer38 < TAP_THRESHOLD) {
      tap(SC_SPACE);
    }
  } else if (layer & TEMPORARY_QWERTY_MASK) {
    release(SC_SPACE);
  }
}

func onPress39() { handlePress(39, SK_E | KEY_STENO, SC_NONE, SC_NONE, SC_SPACE, SC_SPACE); }
func onRelease39() { handleRelease(39, SK_E | KEY_STENO, SC_NONE, SC_NONE, SC_SPACE, SC_SPACE); }

func onPress40() {
  handlePress(40, SK_U | KEY_STENO, SC_NONE, SC_NONE, SC_NONE, SC_KP_0);
  if ((layer | (NAV_MASK | FUNCTION_MASK)) == (NAV_MASK | FUNCTION_MASK)
      || layer == (STENO_MASK | TEMPORARY_QWERTY_MASK)) {
    setLayer((layer | SYMBOL_MASK) & ~NAV_MASK);
    pressAll();

    if (HAS_BLE && isSettingsLayer()) {
      drawBleSummary();
    }
  }
}
func onRelease40() {
  handleRelease(40, SK_U | KEY_STENO, SC_L_CTRL, SC_NONE, SC_NONE, SC_KP_0);
  if (layer & SYMBOL_MASK) {
    setLayer(layer ^ SYMBOL_MASK);
    pressAll();
  }
}

var pressCount41;
func onPress41() {
  handlePress(41, SK_NUM2 | KEY_STENO, SC_NONE, SC_NONE, SC_ENTER, SC_KP_DOT);
  if ((layer | SYMBOL_MASK) == SYMBOL_MASK) {
    pressCount = pressCount + 1;
    setLayer(layer | FUNCTION_MASK);
    pressAll();
    functionLayerPressTimestamp = getTime();
    pressCount41 = pressCount;

    if (HAS_BLE && isSettingsLayer()) {
      drawBleSummary();
    }
  } else if (layer & TEMPORARY_QWERTY_MASK) {
    press(SC_ENTER);
  }
}
func onRelease41() {
  handleRelease(41, SK_NUM2 | KEY_STENO, SC_NONE, SC_NONE, SC_ENTER, SC_KP_DOT);
  if (layer & FUNCTION_MASK) {
    var startPressCount = pressCount;

    setLayer(layer ^ FUNCTION_MASK);
    pressAll();

    if (layer == ALPHABETIC_LAYER) {
      if (!wasSteno24 && isButtonPressed(24)) {
        wasShiftPressed24 = 1;
        press(SC_L_SHIFT);
        updateDisplay0();
      }

      // Give extra time for enter tapping.
      if (pressCount41 == startPressCount && getTime() - functionLayerPressTimestamp < 2*TAP_THRESHOLD) {
        tap(SC_ENTER);
      }

      tap(deferredAlphabeticKey);
    }
    deferredLayerKey = 0;
    deferredAlphabeticKey = 0;
  } else if (layer & TEMPORARY_QWERTY_MASK) {
    release(SC_ENTER);
  }
}
